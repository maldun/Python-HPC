Programming in Python
===========================================

In this section I will give all tools for programming with
Python. The sections are ordered by programming paradigms.
If you are new to programming, the last paragraph of this section 
contains an overview of the paradigms. ( :ref:`paradigm_ref` )

Commenting in Python
-------------------------------------------

To comment out lines of codes use ``#``.

Examples::

  # I'm a comment
  
  x = x + 1 # do some stuff
  
  # bla
  # bla

.. _control_flow_ref:

Go with the control flow
-------------------------------------------

The ``if`` statement
"""""""""""""""""""""""""""""""""""""""""""

The ``if`` statement in Python is quite the way one would
expect from other languages.
As mentioned in the section :ref:`indention_ref` the ``if`` statement
has the following structure::

  if condition_is_true:
      do_something

Note the intendention!

There is also an ``else`` statement in Python::

  if condition_is_true:
      do_something
  else:
      do_something_else

Note that for the ``else`` statement the intendention rule applies
too!

There is also an ``elif`` clause short for else/if::

    if condition_is_true:
        do_something
    elif another_condition_is_true:
        do_something_different
    else:
        do_something_else

Here for example we determine the sign of a value::

  if x > 0:
      sign = 1
  elif x < 0:
      sign = -1
  else:
      sign = 0

``while`` loops
"""""""""""""""""""""""""""""""""""""""""""""

``while`` loops are also like expected::

  while condition_is_true:
      do_something

In Python while loops know alos an ``else`` statement.
It is executed when the condition is violated::

  while condition_is_true:
      do_something
  else:
      do_something

Here an example::

  k = 0
  while k < 10:
      print(k)
      k += 1
  else:
      # if k >= 10 we come into the else clause
      print("Start")

the output of this snippet is::

  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
  Start

``for`` loops
"""""""""""""""""""""""""""""""""""""""""""""""""

For loops are a little bit different in Python,
because in contrast to other programming languages
``for`` iterates through a sequence/list, and not only to integers
or numbers, like in C.

A ``for`` loop looks like this::

  for x in list:
      do_something_with_x

We can use the ``range`` function (see the section about
:ref:`list_ref` ) to create a *norma;* ``for`` loop::

  for i in range(n):
      do_something_with_x

The ``for`` loop knows also an ``else`` statement. It is executed when
``for`` reaches the end of the list/sequence. 

Analogous to our ``while`` example::

  for k in range(10):
      print(k)
  else: 
      # When end of list is reached...
      print("Start")

**Remark:** To get out more performance of your Python code use
``xrange`` instead of range, because ``xrange`` doesn't need allocate
memory for a list. In Python 3, however, ``range`` returns an iterator
and not a list, so this is obsolete there.

See also the Python wiki [#]_ on this topic.

The ``break`` and ``continue`` statements
""""""""""""""""""""""""""""""""""""""""""""

The ``break`` and ``continue`` statements are borrowed from *C*.

* ``continue`` continues with the next iteration of the loop.
  For example::

    >>> k = 0
    >>> for i in range(10):
    ...     k += i
    ...     continue # Go on with next iteration
    ...     print(k) # The interpreter never reaches this line
    ... else:
    ...     print(k) # print result
    ... 
    45

* ``break`` breaks out of the smallest enclosing ``for`` or ``while``
  loop.
  Here a famous example from the official Python tutorial [#]_ ::

    >>> for n in range(2, 10):
    ...     for x in range(2, n):
    ...         if n % x == 0:
    ...             print n, 'equals', x, '*', n/x
    ...             break
    ...     else:
    ...         # loop fell through without finding a factor
    ...         print n, 'is a prime number'
    ...
    2 is a prime number
    3 is a prime number
    4 equals 2 * 2
    5 is a prime number
    6 equals 2 * 3
    7 is a prime number
    8 equals 2 * 4
    9 equals 3 * 3


The ``pass`` statement
"""""""""""""""""""""""""""""""""""""""""""

The ``pass`` statement, in fact, does nothing.
It can be used as a placeholder for functions,
or classe which have to be implemented yet.

For example the snippet
::

  while 1:
      pass

results in an endless loop, where nothing happens.  

Defininng functions
--------------------------------------------------

A function is declared with the ``def`` statement in normal Python
manner.
The statment has to be followed by an identifier
We simply start with a classical example, and give explaination later on.

The factorial would be implemented in Python that way::

  def my_factorial(n, pochhammer = None):
      """ Your documentation comes here"""
      
      if pochhammer is None: # Check if evaluate Pochhammer Symbol
          a = n

      k = 1
      for i in xrange(n):
          k *= a - i

      return k # Give back the result

The ``return`` statement
""""""""""""""""""""""""""""""""""""""""

The ``return`` statement terminate the function and returns the value.
To return more values simply use a comma::

  def f(x,y):
    return 2*x, 3*y

Python return them as a tuple::

  >>> a = f(2,3)
  >>> a
  (4, 9)

If you dont want to store them in a
tuple simple use more identifiers seperated by a comma::

  >>> b,c  = f(2,3)
  >>> b
  4
  >>> c
  9

``return`` without an expression returns ``None``

Variables (inside functions)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Variables within a function are all local, except they are 
defined outside of the code block::

  >>> x = 1      # declared outside of the function
  >>> def f():
  ...     a = 2    # declared inside of the function
  ...     print(x) # can be called within the function
  ... 
  >>> f()
  1
  >>> a # not defined outside of the function
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  NameError: name 'a' is not defined
   But you can't assign values
  to a global variable within a function


But you can't assign a global varaible a new value within a function::

  >>> x = 1
  >>> def f():
  ...     x = 2
  ...     print(x)
  ... 
  >>> f()
  2
  >>> x
  1

except you use the ``global`` statement::

  >>> global Bad    # Declare identifier as global
  >>> Bad = 1       
  >>> def f():
  ...     global Bad  # Tell the function Bad is global 
  ...     Bad = 2
  ...     print(Bad)
  ... 
  >>> Bad
  1
  >>> f()
  2
  >>> Bad
  2

but I would avoid this as much as possible...


Default values and keyword arguments
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Python allows to define functions with default values::

  >>> def answering(name, mission, answer="I don't know"):
  ...     print("What iss your name?")
  ...     print(name)
  ...     print("What iss your mission?")
  ...     print(mission)
  ...     if answer == "I don't know":
  ...         print(answer + " Ahhhhhhhhhh!")
  ...     else:
  ...         print(answer)
  ...         print("You may pass")
  ... 
  >>> answering("Gallahad", "The search for the holy grail")
  What's your name?
  Gallahad
  What's your mission?
  The search for the holy grail
  I dont know Ahhhhhhhhhh!
  >>> answering("Lancelot", "The search for the holy grail", "Blue")
  What's your name?
  Lancelot
  What's your mission?
  The search for the holy grail
  Blue
  You may pass

You can also call them with keyword arguments::

  >>> answering("Lancelot", "The search for the holy grail", answer = "Blue")
  What's your name?
  Lancelot
  What's your mission?
  The search for the holy grail
  Blue
  You may pass

This can be quite useful. For example you want to define a function,
with several options::

  def f(x,y, offset_x = 0, offset_y = 0):
      return 2*x + 2*y + offset_x - offset_y

Now we can call the offset_y variable directly, without setting a
value for offset_x::

   >>> f(0,0,1)
   1
   >>> f(0,0,offset_y = 1)
   -1  

**Important**: A non keyword argument cannot follow a keyword argument::

  >>> f(offset_x = 1,0)
    File "<stdin>", line 1
  SyntaxError: non-keyword arg after keyword arg

This also applies for the definition of the function::

  >>> def g(y = 1,x):
  ...     return x + y
  ... 
    File "<stdin>", line 1
  SyntaxError: non-default argument follows default argument

Calls with lists and dictionaries
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

A function be called with arbitrary many arguments using the
``*`` symbol::

  >>> def sum_up(offset = 0, *summands):
  ...     k = offset
  ...     for x in summands:
  ...         k += x
  ...     return k
  ... 
  >>> sum_up(1)
  1
  >>> sum_up(1,2)
  3
  >>> sum_up(1,2,3)
  6
  >>> sum_up(1,2,3,4)
  10

What happens here? Python wraps all additional arguments into a tuple,
which is identified with the keywords after the ``*``. Very often
as convention ``*args`` is used.

One also can use different types of keywords, and surpass them as
dictionary. Here again an example from the Python documentation::

   def cheeseshop(kind, *arguments, **keywords):
       print "-- Do you have any", kind, "?"
       print "-- I'm sorry, we're all out of", kind
       for arg in arguments:
           print arg
       print "-" * 40
       keys = sorted(keywords.keys())
       for kw in keys:
           print kw, ":", keywords[kw]

It could be called like this::

   cheeseshop("Limburger", "It's very runny, sir.",
              "It's really very, VERY runny, sir.",
              shopkeeper='Michael Palin',
              client="John Cleese",
              sketch="Cheese Shop Sketch")

and of course it would print::

   -- Do you have any Limburger ?
   -- I'm sorry, we're all out of Limburger
   It's very runny, sir.
   It's really very, VERY runny, sir.
   ----------------------------------------
   client : John Cleese
   shopkeeper : Michael Palin
   sketch : Cheese Shop Sketch

Be aware that ``**name`` has to come after ``*name`` (if there is one).

**Remark** The ``*`` operator can be used to unpack contents of a list
and give them to a function as well::

  >>> def f(x,y):
  ...     return x+y
  ... 
  >>> liste = [1,2]
  >>> f(*liste)
  3

Docstrings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Docstrings are optional, and come right after the definition of the
function. A docstring is simply a string. Here is an example::

  >>> def doubling(x):
  ...   """I'm doubling stuff!
  ...      Yes it's true!"""
  ...   return 2*x
  ...  
  >>> print doubling.__doc__
  I'm doubling stuff!
       Yes it's true!

There are many powerful tools like Sphinx, where you can use your
docstrings for creating documentation of your code, or tools for
automatic testing, which read take the docstring as input.

.. _paradigm_ref:


Other ways to define functions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

There are also some other ways to define functions in Python.
One would to be write them in one line, and seperate the different
operations with a semicolon::

  >>> def f(x): y = 2*x; return y
  ... 
  >>> f(2)
  4

Another way is the :math:`\lambda` statement::

  f = lambda x: 2*x

One key difference is, that :math:`lambda` has no return statement,
and it can contain only one expression.

But lambda can take more than one variable::

  lambda x,y: x + y

**Note:** In older versions of Python 2 lambda can unpack tuples::

  lambda (x,y): x + y

is valid in older versions of Python 2, but not in Python 2.6!
In Python 2.6 or above one has to write
::
  
  lambda xy_tuple: xy_tuple[0] + xy_tuple[1]

or

::

  lambda x,y: x + y

instead. 

The :math:`\lambda` statement is confusing many people.
Guido Van Rossum himself wanted to remove the :math:`\lambda`
statement from Python 3, but didn't succeed to find a good replacement
[#]_ . As one of it's biggest fans I can only say: Hooray for
:math:`\lambda` !

The reason for the strange naming is that in the early times of
Python, many *Lisp* programmers wanted some functional features 
from *Lisp*, and one of the was :math:`lambda` .
But it's true origin comes from the :math:`\lambda` calculus [#]_ .

.. _functional_programming_ref:

Functional Programming tools in Python (or hooray for :math:`\lambda` )
------------------------------------------------------------------------

In some sense I'm relaively new to functional programming myself,
in somse sense not, since I use it hidden in some mathemtaical 
languages like Mathematica or Matlab.

Functional programming can be a very powerful tool, and I show here
some of the key features for functional programming in Python.
I follow the `Functional Howto in Python <http://docs.python.org/howto/functional.html/>`_ .

Iterators again
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``pass``

Objects and classes
------------------------------------------------------------------------

Classes are the basis of every OO language, and Python is no exception.

Definition of classes and basic properties
"""""""""""""""""""""""""""""""""""""""""""""

Classes look quite similar to functions::

  class class_name:
      <statement1>
      <statement2>
      .
      .
      .

We use here complex numbers as an example::

  class my_complex:
      """ Complex numbers as example"""
      nr_instances = 0 # This belongs to the whole class

      def __init__(self,re,im):
          """The init method serves as constructor"""
          
          self.re = re
          self.im = im

          my_complex.nr_instances += 1

      def abs(self):
          """Calculates the absolute value"""
          return self.re**2 + self.im**2

What do we have here. First let's look into the ``__init__`` method,
which is the constructor of an object. The first element is the object
itself. Every function (method) of the class takes itself as first
input parameter. The name ``self`` is only a convention, one can use 
every other identifier. **Important**: ``self`` has to be the first
argument in every class method, even when it is not needed!

So what does our constructor here:

* First the object gets it real and imaginary part, simply
  by setting this class member. 
  In Python the object can be created simply by::

    >>> a = my_complex(2,3)
  
  As seen in the constructor we simply added a new class member to
  the object, and in fact, one can always add new class members as 
  he/she wishes::
  
    >>> a.new = 1
    >>> a.new
    1
  
* The last statement simply adds one to the counter, which counts
  the number of instances. We defined it in the beginning of the class
  before the ``__init__`` function. This counter belongs to the whole class,
  that's the reason why we had to call it with
  ``my_complex.nr_instances``.
  And indeed the counter is global for our class::

    >>> a.nr_instances
    1
    >>> b = my_complex(3,4)
    >>> a.nr_instances
    2
    >>> b.nr_instances
    2

  
The next thing we defined is a class method, in this case the
(squared) absolute value. After creating an instance, we can call
it simply like that::

  >>> a.abs()
  13 
    
Huh what happened to the ``self``? The answer is Python takes the self
argument as default, so you don't have to type it anymore.





Some words on programming paradigms
-------------------------------------------

There are several programming paradigms, and the
most common in modern programming languages are

* Imperative programming
* Functional programming
* Object oriented programming

Look at for exmaple at Wikipedia for an short 
overwiev on that topic [#]_, or a good programming book
of your choice, If you want to go deeper into that topic.

In short: 

* In *imperative programming* you define sequences of
  commands the computer should perform, with help of loops,
  control statements, and functions. The program has *states*
  which determine, what the program does, and which action to 
  perform. This is a quite natural approach to programming, because
  a human works also that way, for example: state "hunger" -> get
  food). Classical examples for such languages are *Fortran* (the 
  first high level language) or *C*.

* *Functional programming* is a little bit more artifical, 
   but often a more elegant
   approach for programming. In functional programming you define
   functions and let them operate on objects, lists, or call them
   recursivly. An example would be the *Lisp* family, which was 
   also the first one. (It's worthwile to look at *Lisp* not only
   to customize your Emacs. A good reading tip would be: Practical
   Common Lisp [#]_ ) One important benefit of functional programming
   is, that is easier to parallize. For example it's easier for the 
   compiler/interpreter to decide, when you operate with a function on a list,
   because all operations are independent anyway, than within a for
   loop where the compiler/interpreter doesn't know if there are operations  
   which could be possible connected.
   There are other benefits (see for example the functional
   programming HOWTO in Python [#]_ . 

* *Object oriented programming* is (dear computer scientists, don't
   send me hatemail) more a way to organize your data, and program
   than a real paradigm, and in fact you can program OO even in *C*
   with the help of structs. I already wrote a little about
   that (see :ref:`OO_ref` ), and at least for everyone who does 
   abstraction in a regular  basis this is a very intuitive concept.
   (And in fact every human does! ) 
   OO programming means to collect things, that share specific
   attributes in certain classes. And every Object that shares
   those features belongs to that class. A real world example
   would be wheels: There are big wheels, small wheels, wheels
   for snow etc. but they all share common properties that makes
   them wheels (For example they are all round, 
   and break in a regular basis). 
   
 
The good news are, that in Python you are able to work with
all three at least to some extend. (Python is more imperativ
than funcional). That means Python is a multi paradigm language.

Even if some say that one of the three is the true answer, I
personally think that all three have their benefits and drawbacks,
and thats the reason I prefer multiparadigm languages like Python, because
sometimes it is easier and more intuitive to program a functionality
in one certain way, while it's not so easy in the others.

For example I think it's easier and more elegant to write
:: 

  def f(x): return 2*x
  x = range(10)
  
  x = map(f,x)

than
::

  def f(x): return 2*x
  x = range(10)
  
  for i in x:
      x[i] = f(x[i])


but it's more intuitive and easier to write
::

  def f(x): return 2*x
  x = range(10)
  
  for i in range(0,10,2): 
      x[i] = f(x[i)])
  
than  
::

  def f(x): return 2*x
  x = range(10)
 
  map(lambda i: f(x[i]), range(0,10,2))
  
.. rubric:: Links

.. [#] http://wiki.python.org/moin/PythonSpeed/PerformanceTips
.. [#] http://docs.python.org/tutorial/controlflow.html
.. [#] http://mail.python.org/pipermail/python-dev/2006-February/060415.html
.. [#] http://en.wikipedia.org/wiki/Lambda_calculus
.. [#] http://en.wikipedia.org/wiki/Programming_paradigm
.. [#] http://www.gigamonkeys.com/book/
.. [#] http://docs.python.org/howto/functional.html
