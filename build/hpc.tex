% Generated by Sphinx.
\documentclass[letterpaper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{hpc Documentation}
\date{February 24, 2011}
\release{1.0}
\author{Stefan Reiterer}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex
\makemodindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\hypertarget{--doc-index}{}


Contents:

\resetcurrentobjects
\hypertarget{--doc-Introduction}{}

\chapter{Introduction and personal thoughts}

If you want to start with Python right ahead  follow go directly to ::ref::\emph{basics\_ref}


\section{Foreword}

This short documentation was written by me for the High Performance Computing Seminar
in the winter semester 2010/11 of Prof. G. Haase at the University Graz Austria.

Actually to learn Sphinx and to make it possible for other to get a quick and dirty reference
for working with Python in mathematics and scientific computing I started to write this tech report.

I started with Python last summer, after a short introduction to the \emph{Sage} mathematics software. One could
say it was love at first sight. I was implementing some test code with krylov methods in Matlab and Octave that
time, and was annoyed by the lack of object oriented features like abstracting and capsuling. I had the problem, that
every time I implement a new numerical scheme I have to rewrite the code of my optimisations algorithms, or at least have
to alter it, so that every time I need to retest the new implemtation, which costs time and nerves. And since I'm a
lazy person I didn't want to do that.

I'm now implementing my thesis code in Python, and I also work as a Sage developer in my freetime, and try to help
improving the numerics, optimisations and symbolics parts of Sage which are my personal research interests.

The Python version used here is Python 2.6. since most of the current packages are not ported to Python 3.
But I try to make them compatible with the new version so that this document don't get outdated soon.

This document is aimed towards mathematicians who want learn Python in a quick way to use it.
I have to admit that I'm a beginner too, and would be happy about
feedback on this document. I plan to extend it frequently with tricks
I learned and collected on various newsgroups. I don't know If this is
a good guide, but I hope potential readers have the same fun reading,
I had writing.

And please don't take they sidehits I make too seriously.  (And don't send hatemail on some Java comments!)
People have different opinions and experiences, either with food, cars or programming languages. I only tend to say it more
directly what I feel than other people do. =)

I distribute this under an open license so people can share it
freely. (See Section \hyperlink{license-ref}{\emph{Licenses}}). You are allowed to use and
copy contents as you wish.

Stefan Reiterer,
Graz Austria
2011


\section{Experiences I want to share with programming beginners}

My professors in the basic programming and informatics lectures were all software devolopers, and often cursed programmers from scientific areas,
because of their complicated and often weird codes. I didn't understand their words that time, but since I'm working with libraries like
BLAS, LAPACK, ATLAS etc. I started to understand...

It's true that the processes of software engeneering for ``normal'' applications and scientific computation are two different areas, but I realised in the recent
years that many people from the latter area seem to simply ignore \textbf{nearly all} basic concepts of software design and coding, and I don't know why.
Maybe it's ignorance, because many think they don't need that much programming again, or because they are simply lazy. Another reason could be
that they are too deep into it, and think everyone else think the same way. Perhaps it has historical reasons, like in the case of BLAS,
or it's me because of my friends and education I have a different viewpoint on  that things.

Neverteless I want to use this section to give some important lectures to people, who aren't deep into programming,
I learnt during the last 13 years since I'm started ``programming'' Visual Basic with 13.


\subsection{The Zen of Python don't apply only to Python}

If you type into your Python Interpretor the line

\begin{Verbatim}[commandchars=\\\{\}]
import this
\end{Verbatim}

You will get this:

\textbf{The Zen of Python, by Tim Peters}
\begin{enumerate}
\item {} 
\emph{Beautiful is better than ugly.}

\item {} 
\emph{Explicit is better than implicit.}

\item {} 
\emph{Simple is better than complex.}

\item {} 
\emph{Complex is better than complicated.}

\item {} 
\emph{Flat is better than nested.}

\item {} 
\emph{Sparse is better than dense.}

\item {} 
\emph{Readability counts.}

\item {} 
\emph{Special cases aren't special enough to break the rules.}

\item {} 
\emph{Although practicality beats purity.}

\item {} 
\emph{Errors should never pass silently.}

\item {} 
\emph{Unless explicitly silenced.}

\item {} 
\emph{In the face of ambiguity, refuse the temptation to guess.}

\item {} 
\emph{There should be one-- and preferably only one --obvious way to do it.}

\item {} 
\emph{Although that way may not be obvious at first unless you're Dutch.}

\item {} 
\emph{Now is better than never.}

\item {} 
\emph{Although never is often better than *right} now.*

\item {} 
\emph{If the implementation is hard to explain, it's a bad idea.}

\item {} 
\emph{If the implementation is easy to explain, it may be a good idea.}

\item {} 
\emph{Namespaces are one honking great idea -- let's do more of those!}

\end{enumerate}

This is the philosophy of python and can argue about some the points,
e.g. point 13., but I can say without bad feeling, that \textbf{every}
programmer should especially keep in mind the points 1-7, which apply in every
language you will use!


\subsection{Code is more often read than written}

For every time code is written, it is read about 10 times, and
five times by yourself! If you write code use good and intuitive
names of the variables you use, and make enough comments in your code.
One often writes code, and then have to look at it a month later, and if
you didn't a good work on naming and commenting, you will spend many ours
on trying to understand what you have done that time. And remember: Its \textbf{your} time.
So don't do it unless you want to assure your employment.
And if you want to use short variables like \emph{A} for a matrix make sure to mention
that at the beginning of a function which uses these variables.
And rest assured: Using longer variable names don't cost performance.


\subsection{Program design isn't a waste of time!}

Of course you don't need to design every snippet of code you do,
but at least take your time to think about the implementation, and
how you can eventually reuse it. Sometimes ten minutes of thinking
can save yourself ours of programming.
\hypertarget{oo-ref}{}

\subsection{Object oriented programming abstracts away your problems}

If one is not familiar with the paradigm of object oriented programming change this!
There are tons of books and websites on this topic.
OO programming is not a trend of the last decades, it's the way of abstract mathematics itself.
Mathematicians don't study special cases all the time. We try to exctract the very essence of a class
of problems, and build a theory only using these fundamental properties. This makes it possible to
use theorems on huge classes of problem and not only on one.

Carefully done this saves yourself alot of programming time, because now you are able
to program your algorithms not only for some special input, but for a whole class of objects
in the literal sense.

This semester I gave also an excercise in the optimisation course, where
all the linesearch methods we implemented had to be integrated into one steepest descent algorithm.
While my students needed ours to implement this in Matlab. I only needed one half in Python, because
I simply subdivided the sub problems in classes, and had to write the framework algorithm only once.


\subsection{Modularity counts}

Keep the structure of your programs as modular as possible!
\textbf{Every function should only do exactly one job, and don't use
global variables}. If you have to use global variables, then in
90\% of the cases something is wrong with your design of the code!
Sounds annoying? I was annoyed by that too in my first programming
course. But trust me it will help you a lot. At least if you want to
reuse a piece of code, or even worse, someone else wants to use your
code, you will run into troubles, if you don't have a good
organisation of your code. \textbf{Remember:}  If you have a lot of
parameters, you can always store them in a container or a class.


\subsection{Premature optimisation is the rule of all evil!}

This often cited quote of Donald E. Knuth \footnote{
\href{http://en.wikiquote.org/wiki/Donald\_Knuth}{http://en.wikiquote.org/wiki/Donald\_Knuth}
} is true in it's very deep essence. In an everage program
there are about only 3\% of critical code. But many programmers invest their time to optimise the
other 97\% and wonder why their program isn't getting quicker. The only gain you get is a whole bunch
of unreadible code. I remember that I implemented an ``optimized'' for loop some time ago, and the only gain were
3 ms of more speed. And later when I looked on that function I had no Idea what I did that time...


\subsection{Choice of the right tools}

Since I descend a family of craftsmans, this was taught me very early. You don't want to use
a siedgehammer for hitting a tiny nail into a wall, and you don't want to use small axe to cut down a tree.
(Well I know people who do...). And this applies for programming as well. You don''t want to write a parser in Fortran,
and you don't want to write a program for symbolic manipulation in Java. (I personally would never implement \emph{anything}
mathematical in Java, because it lacks some aspects like operator overloading and efficiency, but that's only a biased opinion.)
The right choice of used languages
and tools, can heavily affect the time you need, and also your success of your projects. It often helps to
ask colleagues, teachers and Google to find the right tool. I list
some of the tools I use here. Keep always in mind that the choice of
your tools, depends also on your personal skills, and
preferences. Something that a colleague of yours like, could possible
a nuissance for yourself.


\subsubsection{Don't use Notepad as your editor!}

A good editor is not expensive (often even free), and saves you a
whole lot of work! Good editors are for example Emacs \footnote{
\href{http://www.gnu.org/software/emacs/}{http://www.gnu.org/software/emacs/}
}, VIM \footnote{
\href{http://www.vim.org/}{http://www.vim.org/}
}.
A good List of editors can be found on Wikipedia. \footnote{
\href{http://en.wikipedia.org/wiki/List\_of\_text\_editors}{http://en.wikipedia.org/wiki/List\_of\_text\_editors}
}


\subsubsection{Use version control}

Many, many people simply don't know there are very nice
tools to keep record of your changes, and make it possible
to redo the changes. Most common are Git \footnote{
\href{http://git-scm.com/}{http://git-scm.com/}
}, Mercurial \footnote{
\href{http://mercurial.selenic.com/}{http://mercurial.selenic.com/}
} (which is written in Python),
or SVN \footnote{
\href{http://subversion.apache.org/}{http://subversion.apache.org/}
}.


\subsubsection{Use debugging tools}

Very good debugging tools are for example Valgrind \footnote{
\href{http://valgrind.org/}{http://valgrind.org/}
}, GDB \footnote{
\href{http://www.gnu.org/software/gdb/}{http://www.gnu.org/software/gdb/}
},
and many, many more... \footnote{
\href{http://en.wikipedia.org/wiki/Debugger}{http://en.wikipedia.org/wiki/Debugger}
}


\subsubsection{Use Linux}

This is of course only a personal recommondation. But Linux is in my opinion better
suited as development enviroment, because most things you need for programming are native, or
already integrated, and even the standard editors know syntax highlighting of the most programming
languages. Even C\# is well integrated in Linux nowadays, and many useful programming tools are simply not
available in Windows (including many of the things we use here).
You don't even need to install a whole Linux distribution. Recently there was a huge development of free
Virtual Machines like Virtual Box \footnote{
\href{http://www.virtualbox.org/}{http://www.virtualbox.org/}
}, or projects like Wubi \footnote{
\href{http://www.ubuntu.com/desktop/get-ubuntu/windows-installer}{http://www.ubuntu.com/desktop/get-ubuntu/windows-installer}
}. And thanks to Distributions like
Ubuntu \footnote{
\href{http://www.ubuntu.com/}{http://www.ubuntu.com/}
}  and it's many derivatives (I use Kubuntu), or open SUSE \footnote{
\href{http://www.opensuse.org/de/}{http://www.opensuse.org/de/}
} using Linux is nowadays possible for
normal humans too.


\subsection{Not everything from Extreme Programming is that bad}

It is shown in many tests that applying the whole concept of XP \footnote{
\href{http://www.extremeprogramming.org/}{http://www.extremeprogramming.org/}
}, simply
doesn't work in practice.
However, done with some moderation the basic concepts of extreme programing can make
the life of a programmer much easier. I personally use this modified subset of rules:
\begin{itemize}
\item {} 
The project is divided into iterations.

\item {} 
Iteration planning starts each iteration.

\item {} 
Pair programming (at least sometimes).

\item {} 
Simplicity.

\item {} 
Create spike solutions to reduce risk.

\item {} 
All code must have unit tests.

\item {} 
All code must pass all unit tests before it  can be released/integrated.

\item {} 
When a bug is found tests are created.

\end{itemize}


\subsection{Examples say more than thousend words!}

Make heavy use of examples. They are a quick reference, and you
can use them for testing your code as well.


\subsection{If your programs aren't understandable nobody will use them}

...including yourself.


\subsection{Use your brain!}

Implicitely used in all points above, this is the most fundamental thing.
Never simply apply concepts or techniques without thinking about the consequences,
or if they are suited for your problems. And yes I include my guidelines here as well.
I met many programmers and software developers, which studied software design, and
how to use design tools, but never really think about the basics. Many bad design decisions
were decided this way!

I also often hear about totally awesome newly discovered concepts, which I use in my daily basis,
because I simply don't want to do unessecary work.
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-Python}{}

\chapter{About Python}


\section{What is Python}

Python is a high level interpreted object oriented (OO) language.
It's main field of application is in web design and scripting.

It was invented by Guido VanRossum in the end of the 80's and the begin of
the 90's \footnote{
\href{http://python-history.blogspot.com/2009/01/brief-timeline-of-python.html}{http://python-history.blogspot.com/2009/01/brief-timeline-of-python.html}
}. The name was derived of the \emph{Monty Python's Flying Curcus}
show.

In the last five years there was a huge development of mathematical tools
and libraries for Python. Actually it seems that there is no particular reason for
this one could see it as a phenomen, or as a trend. But in the meantime the currently
available Python projects reached now dimension that make them vaiable alternatives
for the ``classical'' mathematical languages like Matlab or Mathematica.

Also there are now some very useful tools for code optimisation available like \emph{Cython},
that makes it possible to compile your Python Code to \emph{C} and make it up to 1000x faster,
than normal Python code.

There are several versions of Python interpreters. The interpreter I
refer here as Python is \emph{CPython}, the first interpreter. The CPython interpreter is written,
as the name says, in C. The reason for this choice is, that many
numerical tools are using C bindings, and Cython also works currently
only on CPython. There are also several other
Python Interpreters like Jython (written in Java), PyPy (written in
Python), or IronPython (written in C\#) available.


\section{Why Python?}
\begin{itemize}
\item {} 
Intuitive Syntax

\item {} 
Simple

\item {} 
An easy to learn language.

\item {} 
Object oriented.

\item {} 
Multi paradigm (OO, imperative functional)

\item {} 
Fast (if used with brains).

\item {} 
Rapid development.

\item {} 
A common language, so you will find answers to your problem.

\item {} 
Many nice tools which makes your life easier (like Sphinx, which I use to write this report)

\end{itemize}


\section{Get Python}

The programs and packages used here are all open source, so they can be obtained freely.
Most Linux distributions already ship Python, because many scripts are written in Python.
See also the \emph{Python} project page for further information \footnote{
\href{http://www.python.org/}{http://www.python.org/}
} .

For using Python I personally recommend Linux or a virtual machine
with Linux, because it's much easier to install and handle (for my taste).
But there is currently a .Net Python under development named
IronPython \footnote{
\href{http://ironpython.net/}{http://ironpython.net/}
}.
Not all packages from classical CPython are currently working on IronPython
(including NumPy), but there exists IronClad \footnote{
\href{http://code.google.com/p/ironclad/}{http://code.google.com/p/ironclad/}
} which should make it
possible to use these CPython modules in IronPython.

An easy way to obtain Python is to install \emph{Sagemath} \footnote{
\href{http://www.sagemath.org/}{http://www.sagemath.org/}
}, which contains many useful packages extensions
and packages for mathematics.

Another possibility would be \emph{FEMhub} which is a fork of \emph{Sage} \footnote{
\href{http://www.femhub.org}{http://www.femhub.org}
} . FEMhub is smaller, but more experimental than
Sage, and is aimed only for numerics.
Some of the packages I introduce here are are currently outdated in Sage/FEMhub or not available yet. Current Versions are
available on my Google code project page \footnote{
\href{http://code.google.com/p/computational-sage/}{http://code.google.com/p/computational-sage/}
}.

The drawback of these distributions is that they are not available as .deb or .rpm packages. They have to be build
from source, and currently only work on Linux and other Unix type systems.
But there are precompiled binaries available. (I personally recommand to
build it from source because then many optimisation options are applied)
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-Steps}{}

\hypertarget{basics-ref}{}\chapter{Python Basics}


\section{The ``Goodbye World'' program.}

In the old tradition of the ``\textless{}insert Language here\textgreater{} for Dummies'' books,
we start with the ``Goodbye World'' program.
\begin{enumerate}
\item {} 
Make a file goodbye\_world.py (or what name you like).

\item {} 
Open your Editor.

\item {} 
Write:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Goodbye World!}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

\item {} 
Execute:

\begin{Verbatim}[commandchars=@\[\]]
python goodbye@_world.py
\end{Verbatim}

and you get the output:

\begin{Verbatim}[commandchars=@\[\]]
Goodbye World!
\end{Verbatim}

\end{enumerate}

Thats all!

\textbf{Remark:} If you use Sage as your Python interpreter, simply start the program with

\begin{Verbatim}[commandchars=@\[\]]
sage goodbye@_world.py
\end{Verbatim}

or

\begin{Verbatim}[commandchars=@\[\]]
sage -python goodbye@_world.py
\end{Verbatim}

Alternatively you can do this directly in the interpreter.
\#. Open a shell
\#. Type:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}
\begin{enumerate}
\item {} 
Write:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Goodbye World}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

\end{enumerate}

and press enter.


\section{Notes on the syntax}


\hypertarget{indention-ref}{}\subsection{Intendation for organising blocks of codes}

Codes of blocks are, unlike other programming languages like C++
not organized with parantheses but with indentation. I.e. it looks
like the following:

\begin{Verbatim}[commandchars=@\[\]]
Code outside Block

@textless[]statement@textgreater[] @textless[]identifier(s)@textgreater[] :
    Code in block 1
    Code in block 1
    ...
    @textless[]statement2@textgreater[] @textless[]id@textgreater[] :
        Code in block 2
        Code in block 2
        ...

    Code in block 1
    Code in block 1

    @textless[]statement3 @textless[]id3@textgreater[] :
        Code in block 3

    Code in block 1

Code outside Block
\end{Verbatim}

This sounds for many confusing at the beginning (including myself),
but actually it is not.
After writing some code (with a good editor!) one get's
used to this very quickly.
Try it yourself: After a week or even a month
writing code in Python, go back to Matlab or C.

The benefit of this is, that the code is much more readible,
and a good programmer makes indentation nevertheless.
It's also helpful for debugging: If you make an indentation error
the interpreter knows where it happend, if you forget an \textbf{end} or
an \textbf{\}} the compiler often points you to a line number anywere in the code.

\textbf{Important note:} You can choose the type of indentation as you wish.
One, two, three, four,... 2011 whitespaces, or tabulators. \textbf{But} you should
never mix whitespaces with tabulators! This will result in an error.

Recommended by most  is to use 4
space indentation (This convention is recomended even by the inventor
of Python himself \footnote{
\href{http://www.python.org/dev/peps/pep-0008/}{http://www.python.org/dev/peps/pep-0008/}
})


\subsection{The semicolon}

Generally you don't need a semicolon, and often you don't use it.
It's usage is for putting more than one statment in a line.For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{2}
\end{Verbatim}


\subsection{Identifiers}

Identifier naming follows these rules in Python:
\begin{itemize}
\item {} 
An identifier starts with a letter (lower- or uppercase) or an underscore (\_)

\item {} 
The rest of the identifier can consist of digits (0-9), letters

\item {} 
(lower- or uppercase), and underscores.

\end{itemize}

for example

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{\PYGZus{}bla}
\PYG{n}{no}
\PYG{n}{bla\PYGZus{}bla\PYGZus{}2}
\end{Verbatim}

would be valid,

\begin{Verbatim}[commandchars=@\[\]]
2gether
one space
a-b
\end{Verbatim}

are non valid identifiers.

\textbf{Python is case sensitive!} The identifiers \code{a} and \code{A}
are not the same!


\section{Assignment of variables}

To assign a value to an identifier, we write \code{=}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}
\end{Verbatim}

There is no need to tell Python the data type, because the
interpreter does this for you.

One can also simply change the content:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}
\PYG{g+go}{3}
\end{Verbatim}

Don't worry, Python handle the garbage collection for you.

Like in quite all common programming languges, the value which has to
be assigned to is on the left site, this means the statement

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{Verbatim}

does \emph{first} add one to x and then overwrite x with the new value:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}
\PYG{g+go}{4}
\end{Verbatim}


\section{Some basic datatpypes}

If you need more information on that topic
look in the Python documentation \footnote{
\href{http://docs.python.org/library/stdtypes.html}{http://docs.python.org/library/stdtypes.html}
}.

\textbf{Remark for Sage users} Sage uses it's own
integers or reals. Lookup the documentation
if you need further information.


\subsection{Boolean values}

In Python the following values are considered as false:
\begin{itemize}
\item {} 
\code{None}

\item {} 
\code{False}

\item {} 
Zero of every numeric type, i.e. \code{0},{}`{}`0L{}`{}`,{}`{}`0.0{}`{}`,{}`{}`0j{}`{}` etc.

\item {} 
Empty containers like \code{''}, \code{()}, \code{{[}{]}}

\item {} 
instances of user-defined classes,
if the class defines a \code{\_\_nonzero\_\_()} or \code{\_\_len\_\_()} method,
when that method returns the integer zero or \code{bool} value{}`{}`False{}`{}`.

\end{itemize}

All others are true.


\subsubsection{Boolean operations}

These are the Boolean operations, ordered by ascending priority:

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operation
} & \textbf{
Result
}\\
\hline

\code{x or y}
 & 
if \emph{x} is false, then \emph{y}, else
\emph{x}
\\

\code{x and y}
 & 
if \emph{x} is false, then \emph{x}, else
\emph{y}
\\

\code{not x}
 & 
if \emph{x} is false, then \code{True},
else \code{False}
\\
\hline
\end{tabulary}


The return truly means return! Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{l+m+mi}{2}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{1} \PYG{o+ow}{or} \PYG{l+m+mi}{2}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{o+ow}{not} \PYG{l+m+mi}{1}
\PYG{g+go}{False}
\end{Verbatim}


\subsection{Numbers}

You can represent numbers in many ways:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

is the \textbf{integer} one.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.0}
\end{Verbatim}

is the \textbf{float}  one.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi+il}{1L}
\end{Verbatim}

represents the \textbf{long int} one.

There is also a representation for floats with exponential:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1e3}
\end{Verbatim}

which is thousand, or complex numbers:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{n}{j}
\end{Verbatim}

You can also create numbers directly, with their type specified:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n+nb}{long}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n+nb}{complex}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}


\subsubsection{Arithmetics}

Of course you can use your Python interpreter as a calculator.
Simply call

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}

and then try for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{g+go}{6}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{3}\PYG{o}{-}\PYG{l+m+mi}{2}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{1}\PYG{o}{-}\PYG{l+m+mi}{1}
\PYG{g+go}{0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{g+go}{6}
\end{Verbatim}

Division is a little more tricky in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2}
\PYG{g+go}{0}
\end{Verbatim}

What happened here: A division between two integers return an integer, and Python simply returns the floor.
So taking negative numbers it works in the other direction:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{o}{-}\PYG{l+m+mi}{5}\PYG{o}{/}\PYG{l+m+mi}{2}
\PYG{g+go}{-3}
\end{Verbatim}

If you use the // operator than you force floor division:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mf}{1.5}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{3}
\PYG{g+go}{0.0}
\end{Verbatim}


\subsubsection{More on mathematical operations}

Here is short table on basic operations:

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operation
} & \textbf{
Code
}\\
\hline

$a+b$
 & 
a+b
\\

$a-b$
 & 
a-b
\\

$a\cdot b$
 & 
a*b
\\

$a/b$
 & 
a/b
\\

$a^b$
 & 
a**b
\\

$\lfloor a/b\rfloor$
 & 
a//b
\\

$a \mod b$
 & 
a\%b
\\

$-a$
 & 
-a
\\

$+a$
 & 
+a
\\

$|a|$
 & 
abs(a)
\\

$\overline{a}$
 & 
a.conjugate()
\\
\hline
\end{tabulary}


Some operations can be called by functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{g+go}{8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{8}
\end{Verbatim}

\textbf{Note:} In Python one has also the arithmetic assignemnt operators
\code{+=}, \code{-=}, \code{*=}, \code{/=}, \code{**=}, \code{//=}, \code{\%=}, which
are shortcuts for performing an operation on the variable, and assign
the new value to itself. But there is a little difference: While

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{Verbatim}

creates a new variable that get the new value and deletes the old,
while the \code{+=} operator does this \emph{in place}, which means the
changes are performed on the object itself. (See the Python pitfalls
for more on this \footnote{
\href{http://zephyrfalcon.org/labs/python\_pitfalls.html}{http://zephyrfalcon.org/labs/python\_pitfalls.html}
}) This is done due to performance reasons.

In Python one has also the well known bit operations from
C or C++ which can be performed on integers.

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operation
} & \textbf{
Result
}\\
\hline

\code{x \textbar{} y}
 & 
bitwise \emph{or} of \emph{x} and
\emph{y}
\\

\code{x \textasciicircum{} y}
 & 
bitwise \emph{exclusive or} of
\emph{x} and \emph{y}
\\

\code{x \& y}
 & 
bitwise \emph{and} of \emph{x} and
\emph{y}
\\

\code{x \textless{}\textless{} n}
 & 
\emph{x} shifted left by \emph{n} bits
\\

\code{x \textgreater{}\textgreater{} n}
 & 
\emph{x} shifted right by \emph{n} bits
\\

\code{\textasciitilde{}x}
 & 
the bits of \emph{x} inverted
\\
\hline
\end{tabulary}



\subsection{Container Types}

There are several container types in Python


\hypertarget{list-ref}{}\subsubsection{Lists}

Lists are the most common container type in Python.
To create a list simply write use the rectangular brackets \code{{[},{]}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

The value can be accessed via rectangular brackets again:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{1}
\end{Verbatim}

Note that in Python, like in C, one starts with \code{0} to count.
People who are familiar with Matlab will be happy to here that slicing
is supported as well:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{[1, 2]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{[1, 2, 3]}
\end{Verbatim}

Note that \code{{[}k:n{]}} goes through the indices k to n-1.
Negative indices are also allowed. -1 gives back the last element,
-2 the element before the last element and so on:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{2}
\end{Verbatim}

One can also declare step sizes to go through the indices:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{[1, 3]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{[1, 3]}
\end{Verbatim}

To go backwards through a list use as stepsize -1:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{[3, 2, 1]}
\end{Verbatim}

Lists can also contain elements of various types:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{two}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{liste}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste2}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{[1, 2, 3]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{1}
\end{Verbatim}

The range function helps to create lists:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+go}{[1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{[1, 3]}
\end{Verbatim}

One can also create lists from other containers like strings with the
list function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{abc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{['a', 'b', 'c']}
\end{Verbatim}

There are several methods that can be used on lists:
\begin{itemize}
\item {} 
\code{append} adds an item to a list:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 5]}
\end{Verbatim}

\item {} 
\code{extend} appends a complete list:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste2} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{liste2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8, 6, 7, 8]}
\end{Verbatim}

\item {} 
\code{insert} inserts an element at a given position:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 6, 7, 8]}
\end{Verbatim}

\item {} 
\code{remove} removes the first item from the list, whose value is given:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8, 6, 7, 8]}
\end{Verbatim}

\item {} 
\code{pop} removes the item at the given position:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 6, 7, 8]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8]}
\end{Verbatim}

\item {} 
\code{index} gives back the index of the first element with the value given:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{2}
\end{Verbatim}

\item {} 
\code{count} returns the number how often the element appears in the list:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+go}{2}
\end{Verbatim}

\item {} 
\code{reverse} Reverse the elements in place:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[8, 8, 7, 6, 5, 4, 3, 2, 1, 0]}
\end{Verbatim}

\item {} 
\code{sort} sort the content of the list in place:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 5, 6, 7, 8, 8]}
\end{Verbatim}

\end{itemize}


\subsubsection{Tuples}

Tuples can be created via round brackets:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{coordinate} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

and they can be accessed like lists:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{coordinate}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{coordinate}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{(1,)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{coordinate}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{(1, 2)}
\end{Verbatim}

There is a tuple function too:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{(1, 2)}
\end{Verbatim}

The main difference between tuples and lists, is that the former
are immutable, that means once created you can't change them on
runtime
anymore:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{coordinate}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{"\textless{}stdin\textgreater{}"}, line \PYG{l+m}{1}, in \PYG{n+nIdentifier}{\textless{}module\textgreater{}}
\PYG{n+nc}{TypeError}: \PYG{n+nIdentifier}{'tuple' object does not support item assignment}
\end{Verbatim}


\subsubsection{Dictionaries}

Dictionaries are special containers that take ketwords for access.
They are created with curly brackkets, and each keyword is attached
to value with \code{:}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{one}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{two}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

one can it access now like a list, but with the keyword instead the position:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dic}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{one}\PYG{l+s}{'}\PYG{p}{]}
\PYG{g+go}{1}
\end{Verbatim}

Dictionaries are not immutable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dic}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{one}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dic}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{one}\PYG{l+s}{'}\PYG{p}{]}
\PYG{g+go}{3}
\end{Verbatim}


\subsubsection{Sets}

There are also sets in Python. Like the real sets, they are not
ordered, and every element is contained only once. They are created
with the set function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{menge} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Of course you can't access an element since there is no ordering.
But one can make tests on sets. We come to that right now.


\subsubsection{Membership test}

One can test the membership of elements within containers.
\begin{itemize}
\item {} 
\code{in} tests if an element is in the container and returns True or False:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{5} \PYG{o+ow}{in} \PYG{n}{liste}
\PYG{g+go}{False}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+m+mi}{4} \PYG{o+ow}{in} \PYG{n}{liste}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\end{Verbatim}

\item {} 
\code{not in} ... well make an educated guess.

\end{itemize}


\subsubsection{Other operations on containers}
\begin{itemize}
\item {} 
\code{len} returns the length of an container:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\PYG{g+go}{5}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{tupel} \PYG{o}{=} \PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tupel}\PYG{p}{)}
\PYG{g+go}{4}
\end{Verbatim}

\item {} 
\code{min}, \code{max} return the minimal or the maximal value of the container:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\PYG{g+go}{4}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{tupel}
\PYG{g+go}{(0, 1, 2, 3)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{tupel}\PYG{p}{)}
\PYG{g+go}{0}
\end{Verbatim}

\end{itemize}
\begin{quote}

Note thate the output depends on the order relation between the
objects!
\end{quote}
\begin{itemize}
\item {} 
The \code{+} operator can also be performed to concenate two lists
(\textbf{Note:} \code{set} does not support this!):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste} \PYG{o}{+} \PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]}
\end{Verbatim}

\item {} 
The \code{*} operator makes copies of the same container and concenate
them (\textbf{Note:} \code{set} does not support this!)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+go}{[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{tupel}
\PYG{g+go}{(0, 1, 2, 3)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{tupel}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+go}{(0, 1, 2, 3, 0, 1, 2, 3)}
\end{Verbatim}

\end{itemize}

To be more precise: Those operations are performed on so called
sequence types. These are containers, with have an ordered structure,
which can be addressed via integers (like normal sequences)

Those types are:
* strings
* unicode strings
* lists
* tuples
* iterators

For more information I refer here to the Python documentation again.

For all non-german speakers who wonder why I took liste and not list:
\emph{Liste} means \emph{list} in German, as \emph{tupel} means \emph{tuple} . The benefit
of german names is that they are not reserved, because \code{list} is a
function in Python, and one has to delete the list afterwards:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n+nb}{list}
\end{Verbatim}

Since the german expressions are not that different, I hope people will
understand anyway.


\subsection{Strings}

Strings are containers too, but they are quite special, so they get their
own section here.
There are several ways to create strings in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{bla}\PYG{l+s}{'}
\PYG{n}{b} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{bla}\PYG{l+s}{"}
\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{bla}\PYG{l+s}{"""}
\PYG{n}{d} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{bla}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{l+s}{'''}\PYG{l+s}{bla}\PYG{l+s}{'''}
\end{Verbatim}

The only one of these, which is slightly different is the triple
quote \textbf{`'`} or \textbf{``''``}, which allows multilines and quotes inside
the string:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{o}{=} \PYG{l+s}{"""}\PYG{l+s}{Hi! I}\PYG{l+s}{'}\PYG{l+s}{m the }\PYG{l+s}{"}\PYG{l+s}{best}\PYG{l+s}{"}\PYG{l+s}{ sting in this Universe.}
\PYG{l+s}{            You can believe me, there is no better one.}\PYG{l+s}{"""}
\end{Verbatim}

One can also create strings over more lines using the backslash:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{First }\PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{... }\PYG{l+s}{Second}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}
\PYG{g+go}{'First Second'}
\end{Verbatim}

Note that writing two strings in one command leads to creating only
one string:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{First}\PYG{l+s}{"} \PYG{l+s}{"}\PYG{l+s}{ Second}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}
\PYG{g+go}{'First Second'}
\end{Verbatim}

Of course strings are objects to so you can call class methods on them.

Note that Strings are immutable in Python, which means that you can't
alter it, after you you created it. Like everything this has benefits
and drawbacks.

Another important attribute of strings is that they are containers.
You can access every element like a vector in Matlab:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+s}{"}\PYG{l+s}{hat}\PYG{l+s}{"}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{'h'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+s}{"}\PYG{l+s}{hat}\PYG{l+s}{"}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{'t'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+s}{"}\PYG{l+s}{hat}\PYG{l+s}{"}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{'hat'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+s}{"}\PYG{l+s}{hat}\PYG{l+s}{"}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{'h'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{l+s}{"}\PYG{l+s}{hat}\PYG{l+s}{"}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{'ha'}
\end{Verbatim}

This somehow logical, because every character is simply an object, in
a list of characters, which form the string. People who are coming
from the C world, will be familiar with this, because in C a string
is also a list of chars.


\subsubsection{Special types of strings in Python}

You can specify some types of strings in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{r"}\PYG{l+s}{Newlines are made with }\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{"}
\end{Verbatim}

This makes a raw string, on which no formating as applied.
Capital R works also for this.

We also can create unicode strings with utf8 support:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{kebap} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Drm}\PYG{l+s}{"}
\end{Verbatim}

This looks like the following in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{kebap}
\PYG{g+go}{'D\PYGZbs{}xc3\PYGZbs{}xbcr\PYGZbs{}xc3\PYGZbs{}xbcm'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{kebap}\PYG{p}{)}
\PYG{g+go}{Drm}
\end{Verbatim}


\subsubsection{Basic manipulation of strings}

Two put two strings together one can use the + operator:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{First}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{ Second}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{g+go}{'First Second'}
\end{Verbatim}

Formating like in C is also allowed:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{First }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Second}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{First}
\PYG{g+go}{Second}
\end{Verbatim}

Note again the difference to the raw string:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+s}{r"}\PYG{l+s}{First }\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{n Second}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{First \PYGZbs{}n Second}
\end{Verbatim}

We can also make replacement statements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{breakfast\PYGZus{}everyday} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{I had }\PYG{l+s+si}{\%(SPAM)s}\PYG{l+s}{ pieces of spam, and }\PYG{l+s+si}{\%(EGGS)s}\PYG{l+s}{ eggs for breakfast}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{todays\PYGZus{}spam} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{todays\PYGZus{}eggs} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{breakfast\PYGZus{}today} \PYG{o}{=} \PYG{n}{breakfast} \PYG{o}{\%} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{SPAM}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{todays\PYGZus{}spam}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{EGGS}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{todays\PYGZus{}eggs}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{breakfast\PYGZus{}today}\PYG{p}{)}
\PYG{g+go}{I had 2 pieces of spam, and 3 eggs for breakfast}
\end{Verbatim}

To use the \code{\%} sign in a string you should use a raw string or
simply write \code{\%\%} for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s+si}{\%(NR)s}\PYG{l+s}{ }\PYG{l+s+si}{\%\%}\PYG{l+s}{'} \PYG{o}{\%} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{NR}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{Verbatim}

else you would get an error!

There are other possibilities to replace placeholders:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{"}\PYG{l+s}{There are \PYGZob{}0\PYGZcb{} nuns in this castle!}\PYG{l+s}{"}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{l+s}{"}\PYG{l+s}{\PYGZob{}1\PYGZcb{} plus \PYGZob{}0\PYGZcb{} is \PYGZob{}2\PYGZcb{}}\PYG{l+s}{"}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{l+s}{"}\PYG{l+s}{\PYGZob{}ONE\PYGZcb{} plus 2 is 3}\PYG{l+s}{"}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{ONE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{l+s}{"}\PYG{l+s}{\PYGZob{}numbers[0]\PYGZcb{} plus \PYGZob{}numbers[1]\PYGZcb{} is  \PYGZob{}numbers[2]\PYGZcb{}}\PYG{l+s}{"}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{numbers}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

For further information see the Python documentation on strings \footnote{
\href{http://docs.python.org/library/string.html}{http://docs.python.org/library/string.html}
}


\subsection{Iterators}

An iterator is an object representing a stream of Data, and returns
one element at the time. It is also possible to define infinite
iterators.

To create iterators one can use the \code{iter} function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{iterator} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

There are several datatypes which support iterators. In fact
every sequence type supports iterating (even strings).

Every iterator must support a \code{next} function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{"\textless{}stdin\textgreater{}"}, line \PYG{l+m}{1}, in \PYG{n+nIdentifier}{\textless{}module\textgreater{}}
\PYG{n+nc}{StopIteration}
\end{Verbatim}

Iterators can be converted to lists or tuples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{iterator}\PYG{p}{)}
\PYG{g+go}{[0, 1, 2]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n}{iterator}\PYG{p}{)}
\PYG{g+go}{(0, 1, 2)}
\end{Verbatim}

With help of the \code{itertools} module there are several other ways to
create iterators.
\code{itertools.count} for example creates an infinte stream of
integers.


\section{The print statement}

We used it already some times. Here we give further information.

To print a simple string for example write:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{I}\PYG{l+s}{'}\PYG{l+s}{m a string!}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

or without braces:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{I}\PYG{l+s}{'}\PYG{l+s}{m a string}\PYG{l+s}{"}
\end{Verbatim}

(Why did I always write those stupid brackets, when I don't have to?
I come back later to that topic.)

We can also print numbers or other datatypes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

In fact every class that holds a \_\_str\_\_, or \_\_repr\_\_ method can be printed.
We will come back later to that in the section of :ref: class\_ref .

To print more than one thing you can use a comma (\code{,})
\begin{quote}

print 1, ``plus'', 2, ``is'', 1+2
\end{quote}

this gives back:

\begin{Verbatim}[commandchars=@\[\]]
1 plus 2 is 3
\end{Verbatim}

Note that here with use of the brackets we would get:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{plus}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{is}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{(1, 'plus', 2, 'is', 3)}
\end{Verbatim}

To avoid newline, simply add a comma at the end of the statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{plus}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{is}\PYG{l+s}{"}\PYG{p}{,}
\PYG{k}{print} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}
\end{Verbatim}

\textbf{Note:} In Python 2.x \code{print} is a statement, in Python 3
\code{print} is a function. This is one of the most discussed changes from
Python 2 to Python 3 (see for example this famous thread on the Python
mailinglist \footnote{
\href{http://mail.python.org/pipermail/python-list/2010-June/1248174.html}{http://mail.python.org/pipermail/python-list/2010-June/1248174.html}
} . In order to keep your Code compatible, you can
import the print function with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\end{Verbatim}

In Python 3 the line

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+m+mi}{2}
\end{Verbatim}

would be invalid. One has to use the brackets. This is the reason why
I write here all print statements in brackets to make it easier to
``port'' this document to Python 3.x.

With the print function the statement

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{plus}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{is}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

would now return

\begin{Verbatim}[commandchars=@\[\]]
1 plus 2 is 3
\end{Verbatim}

which was to be expected. The trick with the newline, also doesn't
work anymore. To get newline at the end you would have to write

\begin{Verbatim}[commandchars=@\[\]]
print(1, end=" ")
\end{Verbatim}


\section{Comparison operators}

Here I shortly list the available comparison statments in Python.
The syntax should be very familiar to C programmers.

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operation
} & \textbf{
Meaning
}\\
\hline

\code{\textless{}}
 & 
strictly less than
\\

\code{\textless{}=}
 & 
less than or equal
\\

\code{\textgreater{}}
 & 
strictly greater than
\\

\code{\textgreater{}=}
 & 
greater than or equal
\\

\code{==}
 & 
equal
\\

\code{!=}
 & 
not equal
\\

\code{is}
 & 
object identity
\\

\code{is not}
 & 
negated object identity
\\
\hline
\end{tabulary}


\textbf{Attention:} A trap for beginners (including me) is, that the \code{is}
statment, is different from the \code{==} operator. For example

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{x} \PYG{o+ow}{is} \PYG{l+m+mi}{1}
\end{Verbatim}

does work correctly, but

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{1.0}
\PYG{n}{x} \PYG{o+ow}{is} \PYG{l+m+mf}{1.0}
\end{Verbatim}

does not.
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-Program}{}

\chapter{Programming in Python}

In this section I will give all tools for programming with
Python. The sections are ordered by programming paradigms.
If you are new to programming, the last paragraph of this section
contains an overview of the paradigms. ( \hyperlink{paradigm-ref}{\emph{Other ways to define functions}} )


\section{Commenting in Python}

To comment out lines of codes use \code{\#}.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\# I'm a comment}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{c}{\# do some stuff}

\PYG{c}{\# bla}
\PYG{c}{\# bla}
\end{Verbatim}
\hypertarget{control-flow-ref}{}

\section{Go with the control flow}


\subsection{The \texttt{if} statement}

The \code{if} statement in Python is quite the way one would
expect from other languages.
As mentioned in the section \hyperlink{indention-ref}{\emph{Intendation for organising blocks of codes}} the \code{if} statement
has the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{condition\PYGZus{}is\PYGZus{}true}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something}
\end{Verbatim}

Note the intendention!

There is also an \code{else} statement in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{condition\PYGZus{}is\PYGZus{}true}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something\PYGZus{}else}
\end{Verbatim}

Note that for the \code{else} statement the intendention rule applies
too!

There is also an \code{elif} clause short for else/if:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{condition\PYGZus{}is\PYGZus{}true}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something}
\PYG{k}{elif} \PYG{n}{another\PYGZus{}condition\PYGZus{}is\PYGZus{}true}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something\PYGZus{}different}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something\PYGZus{}else}
\end{Verbatim}

Here for example we determine the sign of a value:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{sign} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{elif} \PYG{n}{x} \PYG{o}{\textless{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{sign} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{1}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{sign} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{Verbatim}


\subsection{\texttt{while} loops}

\code{while} loops are also like expected:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{n}{condition\PYGZus{}is\PYGZus{}true}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something}
\end{Verbatim}

In Python while loops know alos an \code{else} statement.
It is executed when the condition is violated:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{n}{condition\PYGZus{}is\PYGZus{}true}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something}
\end{Verbatim}

Here an example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{k} \PYG{o}{\textless{}} \PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
    \PYG{n}{k} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{else}\PYG{p}{:}
    \PYG{c}{\# if k \textgreater{}= 10 we come into the else clause}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Start}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

the output of this snippet is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{4}
\PYG{l+m+mi}{5}
\PYG{l+m+mi}{6}
\PYG{l+m+mi}{7}
\PYG{l+m+mi}{8}
\PYG{l+m+mi}{9}
\PYG{n}{Start}
\end{Verbatim}


\subsection{\texttt{for} loops}

For loops are a little bit different in Python,
because in contrast to other programming languages
\code{for} iterates through an iterator or an type which supports
iterating, and not only to integers
or numbers, like in C.

A \code{for} loop looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something\PYGZus{}with\PYGZus{}x}
\end{Verbatim}

We can use the \code{range} function (see the section about
\hyperlink{list-ref}{\emph{Lists}} ) to create a \emph{norma;} \code{for} loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{do\PYGZus{}something\PYGZus{}with\PYGZus{}x}
\end{Verbatim}

The \code{for} loop knows also an \code{else} statement. It is executed when
\code{for} reaches the end of the list/sequence.

Analogous to our \code{while} example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{c}{\# When end of list is reached...}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Start}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

\textbf{Remark:} To get out more performance of your Python code use
\code{xrange} instead of range, because \code{xrange} doesn't need allocate
memory for a list. In Python 3, however, \code{range} returns an iterator
and not a list, so this is obsolete then.

See also the Python wiki \footnote{
\href{http://wiki.python.org/moin/PythonSpeed/PerformanceTips}{http://wiki.python.org/moin/PythonSpeed/PerformanceTips}
} on this topic.


\subsection{The \texttt{break} and \texttt{continue} statements}

The \code{break} and \code{continue} statements are borrowed from \emph{C}.
\begin{itemize}
\item {} 
\code{continue} continues with the next iteration of the loop.
For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{k} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}
\PYG{g+gp}{... }    \PYG{k}{continue} \PYG{c}{\# Go on with next iteration}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)} \PYG{c}{\# The interpreter never reaches this line}
\PYG{g+gp}{... }\PYG{k}{else}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)} \PYG{c}{\# print result}
\PYG{g+gp}{...}
\PYG{g+go}{45}
\end{Verbatim}

\item {} 
\code{break} breaks out of the smallest enclosing \code{for} or \code{while}
loop.
Here a famous example from the official Python tutorial \footnote{
\href{http://docs.python.org/tutorial/controlflow.html}{http://docs.python.org/tutorial/controlflow.html}
}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{if} \PYG{n}{n} \PYG{o}{\%} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
\PYG{g+gp}{... }            \PYG{k}{print} \PYG{n}{n}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{equals}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{*}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{n}\PYG{o}{/}\PYG{n}{x}
\PYG{g+gp}{... }            \PYG{k}{break}
\PYG{g+gp}{... }    \PYG{k}{else}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{c}{\# loop fell through without finding a factor}
\PYG{g+gp}{... }        \PYG{k}{print} \PYG{n}{n}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{is a prime number}\PYG{l+s}{'}
\PYG{g+gp}{...}
\PYG{g+go}{2 is a prime number}
\PYG{g+go}{3 is a prime number}
\PYG{g+go}{4 equals 2 * 2}
\PYG{g+go}{5 is a prime number}
\PYG{g+go}{6 equals 2 * 3}
\PYG{g+go}{7 is a prime number}
\PYG{g+go}{8 equals 2 * 4}
\PYG{g+go}{9 equals 3 * 3}
\end{Verbatim}

\end{itemize}


\subsection{The \texttt{pass} statement}

The \code{pass} statement, in fact, does nothing.
It can be used as a placeholder for functions,
or classe which have to be implemented yet.

For example the snippet

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{k}{pass}
\end{Verbatim}

results in an endless loop, where nothing happens.


\section{Defining functions}

A function is declared with the \code{def} statement in normal Python
manner.
The statment has to be followed by an identifier
We simply start with a classical example, and give explaination later on.

The factorial would be implemented in Python that way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}factorial}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{pochhammer} \PYG{o}{=} \PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{""" Your documentation comes here"""}

    \PYG{k}{if} \PYG{n}{pochhammer} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:} \PYG{c}{\# Check if evaluate Pochhammer Symbol}
        \PYG{n}{a} \PYG{o}{=} \PYG{n}{n}

    \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k} \PYG{o}{*}\PYG{o}{=} \PYG{n}{a} \PYG{o}{-} \PYG{n}{i}

    \PYG{k}{return} \PYG{n}{k} \PYG{c}{\# Give back the result}
\end{Verbatim}


\subsection{The \texttt{return} statement}

The \code{return} statement terminate the function and returns the value.
To return more values simply use a comma:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{y}
\end{Verbatim}

Python return them as a tuple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}
\PYG{g+go}{(4, 9)}
\end{Verbatim}

If you dont want to store them in a
tuple simple use more identifiers seperated by a comma:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}  \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b}
\PYG{g+go}{4}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}
\PYG{g+go}{9}
\end{Verbatim}

\code{return} without an expression returns \code{None}


\subsection{Variables (inside functions)}

Variables within a function are all local, except they are
defined outside of the code block:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{1}      \PYG{c}{\# declared outside of the function}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{2}    \PYG{c}{\# declared inside of the function}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{c}{\# can be called within the function}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{c}{\# not defined outside of the function}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{"\textless{}stdin\textgreater{}"}, line \PYG{l+m}{1}, in \PYG{n+nIdentifier}{\textless{}module\textgreater{}}
\PYG{n+nc}{NameError}: \PYG{n+nIdentifier}{name 'a' is not defined}
\PYG{g+go}{ But you can't assign values}
\PYG{g+go}{to a global variable within a function}
\end{Verbatim}

But you can't assign a global varaible a new value within a function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}
\PYG{g+go}{1}
\end{Verbatim}

except you use the \code{global} statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{global} \PYG{n}{Bad}    \PYG{c}{\# Declare identifier as global}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Bad} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{global} \PYG{n}{Bad}  \PYG{c}{\# Tell the function Bad is global}
\PYG{g+gp}{... }    \PYG{n}{Bad} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{Bad}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Bad}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Bad}
\PYG{g+go}{2}
\end{Verbatim}

but I would avoid this as much as possible...


\subsection{Default values and keyword arguments}

Python allows to define functions with default values:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{answering}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{mission}\PYG{p}{,} \PYG{n}{answer}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{I don}\PYG{l+s}{'}\PYG{l+s}{t know}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{What iss your name?}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{What iss your mission?}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{mission}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n}{answer} \PYG{o}{==} \PYG{l+s}{"}\PYG{l+s}{I don}\PYG{l+s}{'}\PYG{l+s}{t know}\PYG{l+s}{"}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{n}{answer} \PYG{o}{+} \PYG{l+s}{"}\PYG{l+s}{ Ahhhhhhhhhh!}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{else}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{You may pass}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{answering}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Gallahad}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{The search for the holy grail}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{What's your name?}
\PYG{g+go}{Gallahad}
\PYG{g+go}{What's your mission?}
\PYG{g+go}{The search for the holy grail}
\PYG{g+go}{I dont know Ahhhhhhhhhh!}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{answering}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Lancelot}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{The search for the holy grail}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{Blue}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{What's your name?}
\PYG{g+go}{Lancelot}
\PYG{g+go}{What's your mission?}
\PYG{g+go}{The search for the holy grail}
\PYG{g+go}{Blue}
\PYG{g+go}{You may pass}
\end{Verbatim}

You can also call them with keyword arguments:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{answering}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Lancelot}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{The search for the holy grail}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{answer} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Blue}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{What's your name?}
\PYG{g+go}{Lancelot}
\PYG{g+go}{What's your mission?}
\PYG{g+go}{The search for the holy grail}
\PYG{g+go}{Blue}
\PYG{g+go}{You may pass}
\end{Verbatim}

This can be quite useful. For example you want to define a function,
with several options:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,} \PYG{n}{offset\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{offset\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{y} \PYG{o}{+} \PYG{n}{offset\PYGZus{}x} \PYG{o}{-} \PYG{n}{offset\PYGZus{}y}
\end{Verbatim}

Now we can call the offset\_y variable directly, without setting a
value for offset\_x:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{offset\PYGZus{}y} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{-1}
\end{Verbatim}

\textbf{Important}: A non keyword argument cannot follow a keyword argument:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{n}{offset\PYGZus{}x} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
  File \PYG{n+nb}{"\textless{}stdin\textgreater{}"}, line \PYG{l+m}{1}
\PYG{n+nc}{SyntaxError}: \PYG{n+nIdentifier}{non-keyword arg after keyword arg}
\end{Verbatim}

This also applies for the definition of the function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{g}\PYG{p}{(}\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
\PYG{g+gp}{...}
  File \PYG{n+nb}{"\textless{}stdin\textgreater{}"}, line \PYG{l+m}{1}
\PYG{n+nc}{SyntaxError}: \PYG{n+nIdentifier}{non-default argument follows default argument}
\end{Verbatim}


\subsection{Calls with lists and dictionaries}

A function be called with arbitrary many arguments using the
\code{*} symbol:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{sum\PYGZus{}up}\PYG{p}{(}\PYG{n}{offset} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{*}\PYG{n}{summands}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{k} \PYG{o}{=} \PYG{n}{offset}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{summands}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{k} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{k}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{sum\PYGZus{}up}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{sum\PYGZus{}up}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{sum\PYGZus{}up}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{sum\PYGZus{}up}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{10}
\end{Verbatim}

What happens here? Python wraps all additional arguments into a tuple,
which is identified with the keywords after the \code{*}. Very often
as convention \code{*args} is used.

One also can use different types of keywords, and surpass them as
dictionary. Here again an example from the Python documentation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cheeseshop}\PYG{p}{(}\PYG{n}{kind}\PYG{p}{,} \PYG{o}{*}\PYG{n}{arguments}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{keywords}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{-- Do you have any}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{kind}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{?}\PYG{l+s}{"}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{-- I}\PYG{l+s}{'}\PYG{l+s}{m sorry, we}\PYG{l+s}{'}\PYG{l+s}{re all out of}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{kind}
    \PYG{k}{for} \PYG{n}{arg} \PYG{o+ow}{in} \PYG{n}{arguments}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{arg}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{-}\PYG{l+s}{"} \PYG{o}{*} \PYG{l+m+mi}{40}
    \PYG{n}{keys} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{keywords}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{kw} \PYG{o+ow}{in} \PYG{n}{keys}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{kw}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{keywords}\PYG{p}{[}\PYG{n}{kw}\PYG{p}{]}
\end{Verbatim}

It could be called like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cheeseshop}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Limburger}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{It}\PYG{l+s}{'}\PYG{l+s}{s very runny, sir.}\PYG{l+s}{"}\PYG{p}{,}
           \PYG{l+s}{"}\PYG{l+s}{It}\PYG{l+s}{'}\PYG{l+s}{s really very, VERY runny, sir.}\PYG{l+s}{"}\PYG{p}{,}
           \PYG{n}{shopkeeper}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Michael Palin}\PYG{l+s}{'}\PYG{p}{,}
           \PYG{n}{client}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{John Cleese}\PYG{l+s}{"}\PYG{p}{,}
           \PYG{n}{sketch}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{Cheese Shop Sketch}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

and of course it would print:

\begin{Verbatim}[commandchars=@\[\]]
-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
\end{Verbatim}

Be aware that \code{**name} has to come after \code{*name} (if there is one).

\textbf{Remark} The \code{*} operator can be used to unpack contents of a list
and give them to a function as well:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{liste}\PYG{p}{)}
\PYG{g+go}{3}
\end{Verbatim}


\subsection{Docstrings}

Docstrings are optional, and come right after the definition of the
function. A docstring is simply a string. Here is an example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{doubling}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }  \PYG{l+s+sd}{"""I'm doubling stuff!}
\PYG{g+gp}{... }\PYG{l+s+sd}{     Yes it's true!"""}
\PYG{g+gp}{... }  \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{doubling}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}
\PYG{g+go}{I'm doubling stuff!}
\PYG{g+go}{     Yes it's true!}
\end{Verbatim}

There are many powerful tools like Sphinx, where you can use your
docstrings for creating documentation of your code, or tools for
automatic testing, which read take the docstring as input.
\hypertarget{paradigm-ref}{}

\subsection{Other ways to define functions}

There are also some other ways to define functions in Python.
One would to be write them in one line, and seperate the different
operations with a semicolon:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:} \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{;} \PYG{k}{return} \PYG{n}{y}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{4}
\end{Verbatim}

Another way is the $\lambda$ statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}
\end{Verbatim}

One key difference is, that $lambda$ has no return statement,
and it can contain only one expression.

In fact lambda returns a function, and is only syntactic sugar,
but it often is very handy.

But lambda can take more than one variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{:} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
\end{Verbatim}

\textbf{Note:} In older versions of Python 2 lambda can unpack tuples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
\end{Verbatim}

is valid in older versions of Python 2, but not in Python 2.6!
In Python 2.6 or above one has to write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{xy\PYGZus{}tuple}\PYG{p}{:} \PYG{n}{xy\PYGZus{}tuple}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{xy\PYGZus{}tuple}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

or

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{:} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
\end{Verbatim}

instead.

The $\lambda$ statement is confusing many people.
Guido Van Rossum himself wanted to remove the $\lambda$
statement from Python 3, but didn't succeed to find a good replacement
\footnote{
\href{http://mail.python.org/pipermail/python-dev/2006-February/060415.html}{http://mail.python.org/pipermail/python-dev/2006-February/060415.html}
} . As one of it's biggest fans I can only say: Hooray for
$\lambda$ !

The reason for the strange naming is that in the early times of
Python, many \emph{Lisp} programmers wanted some functional features
from \emph{Lisp}, and one of the was $\lambda$ .
But it's true origin comes from the $\lambda$ calculus \footnote{
\href{http://en.wikipedia.org/wiki/Lambda\_calculus}{http://en.wikipedia.org/wiki/Lambda\_calculus}
} .

I prefer lambda for some reasons, especially that I can use it inline.
But I wouldn't recommend to use $\lambda$ every time, sometimes the
use of the lambda statement is not good readable.

One may argue that using $\lambda$ too often creates unreadable code.
But on the other hand, it has the benefit, that the actual action is
written right there where it is excecuted, and that can be used to
avoid unnecessary comments, especially if you defined the action
several lines before.

In my work I often have to deal with several mathematical operations.
And yes, I prefer it to write:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}
\end{Verbatim}

over

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{square\PYGZus{}x\PYGZus{}mlt\PYGZus{}y\PYGZus{}to\PYGZus{}pwr\PYGZus{}3\PYGZus{}add\PYGZus{}z\PYGZus{}to\PYGZus{}pwr\PYGZus{}4}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}
\end{Verbatim}

Of course one can also use shorter names like \code{help\_func1}, or
\code{help\_func2} .. and forget which one does what... but you also can
overwrite it again, and again.... and break something in an other part
of your code.

Just my 2 cents.
\hypertarget{functional-programming-ref}{}

\section{Functional Programming tools in Python (or hooray for $\lambda$ )}

In some sense I'm relaively new to functional programming myself,
in somse sense not, since I use it hidden in some mathemtaical
languages like Mathematica or Matlab.

Functional programming can be a very powerful tool, and I show here
some of the key features for functional programming in Python.
I follow here the programming guide for functional programming in
Python \footnote{
\href{http://programming-guides.com/python/functional-programming}{http://programming-guides.com/python/functional-programming}
}. For more advanced techniques and more founded
Background on that topic I refer
to the \emph{Python Functional Programming HOWTO} \footnote{
\href{http://docs.python.org/howto/functional.html}{http://docs.python.org/howto/functional.html}
}


\subsection{The \texttt{map} function}

The \code{map function} takes any number on iterables and a function, and
apply the function on the iterables. That means:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{iter1}\PYG{p}{,} \PYG{n}{iter2}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\end{Verbatim}

returns

\begin{Verbatim}[commandchars=@\[\]]
@PYGZlb[]f(iter1@PYGZlb[]0@PYGZrb[],iter2@PYGZlb[]0@PYGZrb[],..), f(iter1@PYGZlb[]1@PYGZrb[],iter2@PYGZlb[]1@PYGZrb[],...)...@PYGZrb[]
\end{Verbatim}

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{liste} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{n}{liste}\PYG{p}{)}
\PYG{g+go}{[0, 2, 4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{g}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{n}{y}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{liste}\PYG{p}{)}
\PYG{g+go}{[0, 1, 4]}
\end{Verbatim}

This can be very useful for vectorized operations.
Here again the lambda statement comes in handy:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{n}{liste}\PYG{p}{)}
\end{Verbatim}

returns again

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
\end{Verbatim}


\subsection{The \texttt{reduce} function}

Reuce takes as input a list, a function and as optional value an
initial value. Reduce do now the following: It takes the first
elements of the list, and apply the function to it, than it applies
the function to the result and the next element in the list, and again
and again... and returns an value. If an initial value is given
this is taken as the first value. This menas now in expressions that

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{reduce}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{liste}\PYG{p}{)}
\end{Verbatim}

is evaluated as
\begin{quote}

..f(f(f(liste{[}0{]},liste{[}1{]}),liste{[}2{]}),liste{[}3{]})..
\end{quote}

or
\begin{description}
\item[::] \leavevmode
reduce (f,liste,init)

\end{description}

to

\begin{Verbatim}[commandchars=@\[\]]
..f(f(f(init,liste@PYGZlb[]0@PYGZrb[]).liste@PYGZlb[]1@PYGZrb[]),liste@PYGZlb[]2@PYGZrb[])..
\end{Verbatim}

Let's calculate the factorial $10!$

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{reduce}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

or the doubled factorial:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{reduce}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

\textbf{Note} In Python 3 reduce was moved to the \code{functools} module.
It can be backimported via:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n+nb}{reduce}
\end{Verbatim}


\subsection{The \texttt{filter} function}

An important tool to select elements from a list is the filter
function. \code{filter} takes a function and a list and returns, the list
of elements for which the function returned true:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Is\PYGZus{}even}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{return} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\%} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}

\PYG{n+nb}{filter}\PYG{p}{(}\PYG{n}{Is\PYGZus{}even}\PYG{p}{,}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

returns now:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}
\end{Verbatim}
\hypertarget{generators-ref}{}

\subsection{Generators}

Generators are like functions, but they give back a sequence of data
instead of a single output. They can be used to write iterators.

To create an generator, simply write a function with the \code{def}
statement,
but instead of using \code{return} use \code{yield}.

For example

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}even}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{n}
\end{Verbatim}

gives back an iterator witch contains all even numbers.

If we now create an iterator we can do all things which we know:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{iterator} \PYG{o}{=} \PYG{n}{generate\PYGZus{}even}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{iterator}\PYG{p}{)}
\PYG{g+go}{[0, 2, 4, 6, 8]}
\end{Verbatim}

One key difference between generators and functions is, that
while in a function call, all local variables are created once
and are destroyed after \code{return} was called. The varaibles
in an generator stay. You can call \code{return} within an generator
as well, but without output, and after it is called the generator
cannot produce further output.

As an example we write a little program which factors an integer
number with help of functional tools:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}

\PYG{k}{def} \PYG{n+nf}{find\PYGZus{}factors}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}\PYG{p}{:}
  \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{  Find prime factors of a number iterativly}
\PYG{l+s+sd}{  """}
  \PYG{c}{\# we take advantage of the fact that (i +1)**2 = i**2 + 2*i +1}
  \PYG{n}{i}\PYG{p}{,} \PYG{n}{sqi} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{sqi} \PYG{o}{\textless{}}\PYG{o}{=} \PYG{n}{num}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
      \PYG{n}{sqi} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
      \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
      \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}
      \PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{num} \PYG{o}{\%} \PYG{n}{i}\PYG{p}{:}
          \PYG{n}{num} \PYG{o}{/}\PYG{o}{=} \PYG{n}{i}
          \PYG{n}{k} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

      \PYG{k}{yield} \PYG{n}{i}\PYG{p}{,}\PYG{n}{k}

\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}factors}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{"}\PYG{l+s}{**}\PYG{l+s}{"} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{end} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{ }\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{end}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{ }\PYG{l+s}{"}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{factorise}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{    Find prime factors and print them}
\PYG{l+s+sd}{    """}

    \PYG{n}{factor\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{find\PYGZus{}factors}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}power}\PYG{p}{(}\PYG{n}{pair}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{n}{pair}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{factor\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{n}{get\PYGZus{}power}\PYG{p}{,} \PYG{n}{factor\PYGZus{}list}\PYG{p}{)}

    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{factor\PYGZus{}list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{factor\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o+ow}{is} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{PRIME}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{ }\PYG{l+s}{"}\PYG{p}{)}
        \PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{print\PYGZus{}factors}\PYG{p}{,} \PYG{n}{factor\PYGZus{}list}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}


\subsection{List Comprehensions}

List comprehensions are often a good alternative to \code{map},
\code{filter} and \code{lambda}. A list comprehension consists of an
expression followed by an \code{for} clause, which are followed by
zero or more \code{for} and/or \code{if} clauses. The whole thing is
surrounded by rectangular brackets.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{vector} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{vector}\PYG{p}{]}
\PYG{g+go}{[0, 6, 12, 18, 24]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{vector} \PYG{k}{if} \PYG{n}{x} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+go}{[8, 12, 16]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{vector1} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{vector2} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{p}{[}\PYG{n}{x}\PYG{o}{*}\PYG{n}{y} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{vector1} \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n}{vector2}\PYG{p}{]} \PYG{c}{\# Goes through all combinations}
\PYG{g+go}{[0, 0, 0, 0, 2, 4, 0, 4, 8]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{p}{[}\PYG{n}{vector1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{vector2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{vector1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]} \PYG{c}{\# mimic map}
\PYG{g+go}{[0, 2, 8]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{n}{y}\PYG{p}{,}\PYG{n}{vector1}\PYG{p}{,}\PYG{n}{vector2}\PYG{p}{)} \PYG{c}{\#equivalent statement}
\PYG{g+go}{[0, 2, 8]}
\end{Verbatim}

List comprehensions can also be applied to much more complex
expressions, and nested functions.


\section{Objects and classes}

Classes are the basis of every OO language, and Python is no exception.


\subsection{Definition of classes and basic properties}

Classes look quite similar to functions:

\begin{Verbatim}[commandchars=@\[\]]
class class@_name:
    @textless[]statement1@textgreater[]
    @textless[]statement2@textgreater[]
    .
    .
    .
\end{Verbatim}

We use here complex numbers as an example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{my\PYGZus{}complex}\PYG{p}{:}
    \PYG{l+s+sd}{""" Complex numbers as example"""}
    \PYG{n}{nr\PYGZus{}instances} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c}{\# This belongs to the whole class}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{re}\PYG{p}{,}\PYG{n}{im}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{"""The init method serves as constructor"""}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re} \PYG{o}{=} \PYG{n}{re}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im} \PYG{o}{=} \PYG{n}{im}

        \PYG{n}{my\PYGZus{}complex}\PYG{o}{.}\PYG{n}{nr\PYGZus{}instances} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{def} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{"""Calculates the absolute value"""}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\end{Verbatim}

What do we have here. First let's look into the \code{\_\_init\_\_} method,
which is the constructor of an object. The first element is the object
itself. Every function (method) of the class takes itself as first
input parameter. The name \code{self} is only a convention, one can use
every other identifier. \textbf{Important}: \code{self} has to be the first
argument in every class method, even when it is not needed!

So what does our constructor here:
\begin{itemize}
\item {} 
First the object gets it real and imaginary part, simply
by setting this class member.
In Python the object can be created simply by:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{my\PYGZus{}complex}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{Verbatim}

As seen in the constructor we simply added a new class member to
the object, and in fact, one can always add new class members as
he/she wishes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{new} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{new}
\PYG{g+go}{1}
\end{Verbatim}

\item {} 
The last statement simply adds one to the counter, which counts
the number of instances. We defined it in the beginning of the class
before the \code{\_\_init\_\_} function. This counter belongs to the whole class,
that's the reason why we had to call it with
\code{my\_complex.nr\_instances}.
And indeed the counter is global for our class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{nr\PYGZus{}instances}
\PYG{g+go}{1}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{my\PYGZus{}complex}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{nr\PYGZus{}instances}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{nr\PYGZus{}instances}
\PYG{g+go}{2}
\end{Verbatim}

\end{itemize}

The next thing we defined is a class method, in this case the
(squared) absolute value. After creating an instance, we can call
it simply like that:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{13}
\end{Verbatim}

Huh what happened to the \code{self}? The answer is Python takes the self
argument as default, so you don't have to type it anymore.


\subsection{Deriving classes from other classes and overloading of methods}

This is rather easy in Python. To tell the interpreter from which
class he should derive the new class, simple put it into round
brackets. To to overload a certain function simply add it again.

Let's go back to our complex number example. It annoys us, that
the absolute value is squared, but we don't want a new constructor.
So we simply derive The old complex class, and overload the absolute
value:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{my\PYGZus{}new\PYGZus{}complex}\PYG{p}{(}\PYG{n}{my\PYGZus{}complex}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{"""Calculates the absolute value"""}
        \PYG{k}{return} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
\end{Verbatim}

What does Python internally? After it checked
which functions are already defined in the new class
it adds all members from the old.
With that logic one also can inherit from multiple base classes.
After checking what's in the new class, it looks what is in the first
class given, then in the second, and so on.
Consider the for example in the class

\begin{Verbatim}[commandchars=@\[\]]
new@_class(base1,base2,base3)
    pass
\end{Verbatim}

the priority order for looking up new methods is new\_class-\textgreater{} base1 -\textgreater{}
base2 -\textgreater{} base3 and not new\_class -\textgreater{} base3 -\textgreater{} base2 -\textgreater{} base1.
\hypertarget{overload-ref}{}

\subsection{Operator overloading}

In my opinion one of the most powerful features in OO languages, and
the reason why I think Java isn't worth to look at it.

Especially in mathematics one wants to define new algebras or objects
with algebraic operations, to make programs more readable and
algorithms reusable.

In order to overload operators in Python classes one has only to
add the right methods. Now let's add +, * operations to our complex number
class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{n}{my\PYGZus{}new\PYGZus{}complex}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re} \PYG{o}{+} \PYG{n}{other}\PYG{o}{.}\PYG{n}{re}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im} \PYG{o}{+} \PYG{n}{other}\PYG{o}{.}\PYG{n}{im}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}mul\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{re} \PYG{o}{-} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{im}\PYG{p}{,}
                               \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{im} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{re}\PYG{p}{)}
\end{Verbatim}

The \code{\_\_add\_\_} and \code{\_\_mul\_\_} functions return new objects of
the complex class. The good thing is we can use the normal \code{+}
and \code{*} operators:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{re}
\PYG{g+go}{8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{im}
\PYG{g+go}{11}
\end{Verbatim}

One can also add additional features like a string representation,
that \code{print} is able to return. Lets add a \code{\_\_repr\_\_} method to
the class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{n}{my\PYGZus{}new\PYGZus{}complex}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re} \PYG{o}{+} \PYG{n}{other}\PYG{o}{.}\PYG{n}{re}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im} \PYG{o}{+} \PYG{n}{other}\PYG{o}{.}\PYG{n}{im}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}mul\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{re} \PYG{o}{-} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{im}\PYG{p}{,}
                               \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{im} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im}\PYG{o}{*}\PYG{n}{other}\PYG{o}{.}\PYG{n}{re}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s}{\PYGZob{}0\PYGZcb{} + \PYGZob{}1\PYGZcb{}i}\PYG{l+s}{"}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{re}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{im}\PYG{p}{)}
\end{Verbatim}

Now we can print our complex class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{my\PYGZus{}nice\PYGZus{}complex}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{3 + 4i}
\end{Verbatim}

There is a whole bunch of features that can be added to a class.
I refer here to the Python reference manual for a complete list \footnote{
\href{http://docs.python.org/reference/datamodel.html\#special-method-names}{http://docs.python.org/reference/datamodel.html\#special-method-names}
},
because listing them all here would be too long.


\section{Exceptions}

What is an exception? An exception is a special
object (yes exceptions are objects too!) which
to tell the interpreter that something happended, which
shouldn't have (or sometimes it is expected), then
the interpreter tells you that it caught an exception.
Of course it is possible to tell the interpreter what to
do when an exception arises. This allows many advanced possibilites
for the programmer.

Python has many builtin exceptions like out of range exceptions
division by zero exceptions and so on.

Exceptions are a powerful tool in programming languages to
find errors, and provide a safe workflow. Exceptions can also
be used for control flow. In fact handling exceptions can yield
better performance, than many \code{if} statements, because the
interpreter checks \emph{many} \code{if} s but only has to wait for \emph{one}
exception.


\subsection{Handling exceptions}

To catch exceptions us the \code{try} and \code{except}
statements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{0}
\PYG{k}{except} \PYG{n+ne}{ZeroDivisionError}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{I don{}`t think so, Tim.}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

What happens here? The try statement excecutes the following
codeblock. If an exception of the type ZeroDivisionError arises
it executes the code block after the except statement.
Of course one can handle sever different exception types.
Only add more except statments:

\begin{Verbatim}[commandchars=@\[\]]
try:
    do@_something
except exception@_type1:
    do@_that
except exception@_type2, and@_exception@_type3:
    do@_this
.
.
.
\end{Verbatim}

With help of the \code{raise} can also force the program to throw
exceptions. For example

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{spam}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{eggs}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{"\textless{}stdin\textgreater{}"}, line \PYG{l+m}{1}, in \PYG{n+nIdentifier}{\textless{}module\textgreater{}}
\PYG{n+nc}{Exception}: \PYG{n+nIdentifier}{('spam', 'eggs')}
\end{Verbatim}

This is important to throw the correct exceptions of certain types,
with user defined error messages. This makes debugging a lot easier!

There is another possibility in Python: So called clean up actions,
which have to executed at all costs (for example cleaning up allocated
memory). Those can be specified via the \code{finally} statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{raise} \PYG{n+ne}{KeyboardInterrupt}
\PYG{g+gp}{... }\PYG{k}{finally}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{I don{}`t think so, Tim.}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{I don{}`t think so, Tim.}
\PYG{n+nc}{KeyboardInterrupt}
\end{Verbatim}

Here a more advanced example for exception handling: Let's remember our prime
factor example from the \hyperlink{generators-ref}{\emph{Generators}} section. We want that the
function should only handle integers, so we check this with help of
exceptions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}

\PYG{k}{def} \PYG{n+nf}{find\PYGZus{}factors}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}\PYG{p}{:}
  \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{  Find prime factors of a number iterativly}
\PYG{l+s+sd}{  """}

  \PYG{c}{\# we take advantage of the fact that (i +1)**2 = i**2 + 2*i +1}
  \PYG{n}{i}\PYG{p}{,} \PYG{n}{sqi} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}
  \PYG{k}{while} \PYG{n}{sqi} \PYG{o}{\textless{}}\PYG{o}{=} \PYG{n}{num}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
      \PYG{n}{sqi} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
      \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
      \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}
      \PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{num} \PYG{o}{\%} \PYG{n}{i}\PYG{p}{:}
          \PYG{n}{num} \PYG{o}{/}\PYG{o}{=} \PYG{n}{i}
          \PYG{n}{k} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

      \PYG{k}{yield} \PYG{n}{i}\PYG{p}{,}\PYG{n}{k}

\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}factors}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{"}\PYG{l+s}{**}\PYG{l+s}{"} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{end} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{ }\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{num\PYGZus{}fac}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{end}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{ }\PYG{l+s}{"}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{factorise}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{    Find prime factors and print them}
\PYG{l+s+sd}{    """}

    \PYG{k}{try}\PYG{p}{:}                             \PYG{c}{\#check if num is an integer}
        \PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}             \PYG{c}{\#with exceptions}
        \PYG{k}{if} \PYG{n}{num} \PYG{o}{!=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ValueError}
    \PYG{k}{except} \PYG{p}{(}\PYG{n+ne}{ValueError}\PYG{p}{,} \PYG{n+ne}{TypeError}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Can only factorise an integer}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{n}{factor\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{find\PYGZus{}factors}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}power}\PYG{p}{(}\PYG{n}{pair}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{n}{pair}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{factor\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{n}{get\PYGZus{}power}\PYG{p}{,} \PYG{n}{factor\PYGZus{}list}\PYG{p}{)}

    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{factor\PYGZus{}list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{factor\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o+ow}{is} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{PRIME}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{ }\PYG{l+s}{"}\PYG{p}{)}
        \PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{print\PYGZus{}factors}\PYG{p}{,} \PYG{n}{factor\PYGZus{}list}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

Compare this to the last programming example of this page \footnote{
\href{http://pleac.sourceforge.net/pleac\_python/numbers.html}{http://pleac.sourceforge.net/pleac\_python/numbers.html}
} , which is
an imperative solution.

For further information on Exceptions see the Python documentation \footnote{
\href{http://docs.python.org/tutorial/errors.html}{http://docs.python.org/tutorial/errors.html}
}


\subsection{Creating new exceptions}

Since Exceptions are classes too, they can be simply created by
deriving them from the \code{Exception} base class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{ToolTimeException}\PYG{p}{(}\PYG{n+ne}{Exception}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{stupid\PYGZus{}comment}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{stupid\PYGZus{}comment}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{stupid\PYGZus{}comment} \PYG{o}{+}  \PYG{l+s}{"}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{I don}\PYG{l+s}{'}\PYG{l+s}{t think so, Tim}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

Then you can normally raise it:

\begin{Verbatim}[commandchars=@\[\]]
@textgreater[]@textgreater[]@textgreater[] raise ToolTimeException("And if you're painting Al's mom, you can \
... get it done in a matter of years." )
Traceback (most recent call last):
  File "@textless[]stdin@textgreater[]", line 2, in @textless[]module@textgreater[]
@_@_main@_@_.ToolTimeException
And if you're painting Al's mom, you can get it done in a matter of years.
I don't think so, Tim
\end{Verbatim}


\section{Modules and Packages}

Of course no one wants to type everything into the interpreter all the
time, but safe the programs into files and execute them by calling a
function. We learn how to do this in Python.


\subsection{Modules}

We alredy dealt indirectly with modules. Modules are several
functions, classes etc. stored in a file with a \code{.py} suffix,
like we did in the \emph{Goodbye World} example.

For example lets write a a file with some functions in it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}

\PYG{k}{def} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
\end{Verbatim}

Now save them in a file. Let's say \code{powers.py}.

Now you can import it into Python with the \code{import} statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{powers}
\end{Verbatim}

From that on, you can call at's functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{powers}\PYG{o}{.}\PYG{n}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{9}
\end{Verbatim}

We called the square function like a class member, and in fact a
module is a \emph{class}.

If one don't want to import a part of a module directly, one
can use the \code{from...import} statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{powers} \PYG{k+kn}{import} \PYG{n}{cube}
\end{Verbatim}

Now cube can be called directly:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cube}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{27}
\end{Verbatim}

This is also a great benefit over Matlab: You can do as many functions
as you want into one file.


\subsection{Packages}

To construct trees of modules we can organise them in packages.
To make a package do the following:
Save all modules that should belong to the package into a directory
with the name of the package. Then add an (most times empty) file
named \code{\_\_init\_\_.py} to the folder. For example we want our power
module into an math\_stuff package which also holds an module for
roots of several powers. First we make a directory \code{math\_stuff}

So we write that module:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}

\PYG{k}{def} \PYG{n+nf}{curt}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}
\end{Verbatim}

and save it to a file \code{roots.py} in the \code{math\_stuff} directory.
Then we create an empty file \code{\_\_init\_\_.py} in that folder.

\textbf{Important} make sure to be in the right working directory!
There are several possiblities to do that:
\begin{itemize}
\item {} 
\code{cd} to your directory in a shell and call Python there. Then the
current directory is also your working directory.

\item {} 
In Python, you can achieve that by using the \code{chdir} function from
the \code{os} module:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{n}{chdir}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{chdir}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{/the/folder/math\PYGZus{}stuff\PYGZus{}is\PYGZus{}in/}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

\item {} 
In IPython or Sage simply use the command cd in the
interpreter.

\end{itemize}

Now you can normally import the powers module by:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{import} \PYG{n+nn}{math\PYGZus{}stuff.powers}
\end{Verbatim}

and call it's functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{math\PYGZus{}stuff}\PYG{o}{.}\PYG{n}{powers}\PYG{o}{.}\PYG{n}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{16}
\end{Verbatim}

To build subpackages one only has to create a subfolder with
the name of the subpackage and put an \code{\_\_init\_\_.py} file into
a that subfolder, and so on.

There are several more things one can do, for example
make it possible to import the complete namespace with \code{*}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

Now you can use every function and submodule of the \code{os} package,
without typing \code{os.whatever}. I personally don't recommand that
because of two reasons:
\begin{itemize}
\item {} 
If you load to much modules, which have quite similar functions
(for example every math packages has it's \code{sin} function, then you
can run into troubles.

\item {} 
It yields better performance. The more functions and modules are
loaded the more load has the interpreter to deal with.

\end{itemize}

I recommend personally to import explicitly with \code{from ... import}
only the functions you actually need.

For further information see the Python documention \footnote{
\href{http://docs.python.org/tutorial/modules.html}{http://docs.python.org/tutorial/modules.html}
}.


\section{Reading and Writing external files}

To read or writing external files you first have to open it. We
do this with the open function: \code{open(filename,mode)}. The modes are
\code{'r'} (\textbf{r} ead only), \code{'w'} (\textbf{w} rite only; a file with the same name will
be deleted), \code{'a'} (\textbf{a} ppends data to the end of the file),
\code{'r+'} (read and write). Default mode is \code{'r'}. Open returns a
object of the type FileObject.

You find more information at the Python documentation \footnote{
\href{http://docs.python.org/tutorial/inputoutput.html}{http://docs.python.org/tutorial/inputoutput.html}
}, \footnote{
\href{http://docs.python.org/library/stdtypes.html\#bltin-file-objects}{http://docs.python.org/library/stdtypes.html\#bltin-file-objects}
}

Examples: We write some text to a file, named test\_file.txt and store
it in the working directory, containing the following text:

\begin{Verbatim}[commandchars=@\[\]]
I am a file. This is my first line
Second line.
Third line.
\end{Verbatim}

Now let's print it in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}file.txt}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{r}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'I am a file. This is my first line\PYGZbs{}nSecond line.\PYGZbs{}nThird line.'}
\end{Verbatim}

\code{read} prints the content of the file till it reaches it's end,
and returns the content as string.
You can also tell \code{read} to read a certain amount of bytes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}file.txt}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{r}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+go}{'I am a file.'}
\end{Verbatim}

We can also read line for line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}file.txt}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{r}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'I am a file. This is my first line\PYGZbs{}n'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'Second line.\PYGZbs{}n'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'Third line.'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{''}
\end{Verbatim}

\code{readline} prints the line till it finds \code{\textbackslash{}n}.
Note that we had to reopen the file, because the we reached the
end of the file after the first read call. With help of the seek
method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}file.txt}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{r}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+go}{'I am a file.'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{tell}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{12L}
\end{Verbatim}

To set a different position we use the \code{seek} method. \code{seek} goes
to number of bytes from the position which is set. As default \code{seek}
uses \code{0} (beginning of file; is equivalent to
\code{os.SEEK\_CUR}). Other values are \code{1} (the current position;
os.SEEK\_CUR) or \code{2} (end of file; os.SEEK\_END).

For example let's read the first line of the file, and jump to the
next line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'I am a file. This is my first line\PYGZbs{}n'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'Third line.'}
\end{Verbatim}

Alternativley we can use the system's constants:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{n}{SEEK\PYGZus{}CUR}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'I am a file. This is my first line\PYGZbs{}n'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{n}{SEEK\PYGZus{}CUR}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{'Third line.'}
\end{Verbatim}

The command \code{readlines} prints the lines from the
file in a list:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{['I am a file. This is my first line\PYGZbs{}n', 'Second line.\PYGZbs{}n', 'Third line.']}
\end{Verbatim}

To close the file again, use the close method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}
\PYG{g+go}{\textless{}closed file 'test\PYGZus{}file.txt', mode 'r' at 0xb7866b10\textgreater{}}
\end{Verbatim}

Now let's add a new line to the file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}file.txt}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{a}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{This is the fourth line.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}file.txt}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{r}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{I am a file. This is my first line}
\PYG{g+go}{Second line.}
\PYG{g+go}{Third line.}
\PYG{g+go}{This is the fourth line.}
\end{Verbatim}

We can also do that interactively:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}file.txt}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{r+}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{This is the fift line.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

The file will only be changed on the disc if we close it
or use the \code{flush} method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{flush}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Now we can read it again:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{I am a file. This is my first line}
\PYG{g+go}{Second line.}
\PYG{g+go}{Third line.}
\PYG{g+go}{This is the fourth line.}
\PYG{g+go}{This is the fift line.}
\end{Verbatim}

Oops we forgot an `h'. Let's change this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{h line.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{flush}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{I am a file. This is my first line}
\PYG{g+go}{Second line.}
\PYG{g+go}{Third line.}
\PYG{g+go}{This is the fourth line.}
\PYG{g+go}{This is the fifth line.}
\end{Verbatim}

The writelines command make it possible to add a list of strings:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{6th line}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{"}\PYG{l+s}{7th line}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{I am a file. This is my first line}
\PYG{g+go}{Second line.}
\PYG{g+go}{Third line.}
\PYG{g+go}{This is the fourth line.}
\PYG{g+go}{This is the fifth line.}
\PYG{g+go}{6th line}
\PYG{g+go}{7th line}
\end{Verbatim}


\section{Some words on programming paradigms}

There are several programming paradigms, and the
most common in modern programming languages are
\begin{itemize}
\item {} 
Imperative programming

\item {} 
Functional programming

\item {} 
Object oriented programming

\end{itemize}

Look at for exmaple at Wikipedia for an short
overwiev on that topic \footnote{
\href{http://en.wikipedia.org/wiki/Programming\_paradigm}{http://en.wikipedia.org/wiki/Programming\_paradigm}
}, or a good programming book
of your choice, If you want to go deeper into that topic.

In short:
\begin{itemize}
\item {} 
In \emph{imperative programming} you define sequences of
commands the computer should perform, with help of loops,
control statements, and functions. The program has \emph{states}
which determine, what the program does, and which action to
perform. This is a quite natural approach to programming, because
a human works also that way, for example: state ``hunger'' -\textgreater{} get
food). Classical examples for such languages are \emph{Fortran} (the
first high level language) or \emph{C}.

\item {} \begin{description}
\item[\emph{Functional programming} is a little bit more artifical,] \leavevmode
but often a more elegant
approach for programming. In functional programming you define
functions and let them operate on objects, lists, or call them
recursivly. An example would be the \emph{Lisp} family, which was
also the first one. (It's worthwile to look at \emph{Lisp} not only
to customize your Emacs. A good reading tip would be: Practical
Common Lisp \footnote{
\href{http://www.gigamonkeys.com/book/}{http://www.gigamonkeys.com/book/}
} ) One important benefit of functional programming
is, that is easier to parallize. For example it's easier for the
compiler/interpreter to decide, when you operate with a function on a list,
because all operations are independent anyway, than within a for
loop where the compiler/interpreter doesn't know if there are operations
which could be possible connected. Other benefits are listed in
the \emph{Python Functional Programming Howto}.

\end{description}

\item {} \begin{description}
\item[\emph{Object oriented programming} is (dear computer scientists, don't] \leavevmode
send me hatemail) more a way to organize your data, and program
than a real paradigm, and in fact you can program OO even in \emph{C}
with the help of structs. I already wrote a little about
that (see \hyperlink{oo-ref}{\emph{Object oriented programming abstracts away your problems}} ), and at least for everyone who does
abstraction in a regular  basis this is a very intuitive concept.
(And in fact every human does! )
OO programming means to collect things, that share specific
attributes in certain classes. And every Object that shares
those features belongs to that class. A real world example
would be wheels: There are big wheels, small wheels, wheels
for snow etc. but they all share common properties that makes
them wheels (For example they are all round,
and break in a regular basis).

\end{description}

\end{itemize}

The good news are, that in Python you are able to work with
all three at least to some extend. (Python is more imperativ
than funcional). That means Python is a multi paradigm language.

Even if some say that one of the three is the true answer, I
personally think that all three have their benefits and drawbacks,
and thats the reason I prefer multiparadigm languages like Python, because
sometimes it is easier and more intuitive to program a functionality
in one certain way, while it's not so easy in the others.

For example I think it's easier and more elegant to write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

than

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{x}\PYG{p}{:}
    \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

but it's more intuitive and easier to write

\begin{Verbatim}[commandchars=@\[\]]
def f(x): return 2*x
x = range(10)

for i in range(0,10,2):
    x@PYGZlb[]i@PYGZrb[] = f(x@PYGZlb[]i)@PYGZrb[])
\end{Verbatim}

than

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{i}\PYG{p}{:} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-Scientific}{}

\chapter{Scientific tools in Python}


\section{NumPy}

NumPy is based on the old Python Project Numeric, and introduces a
Matlab like vector class to Python. Numpy is currently developed by
Entought and is distrubuted und the BSD license. Further Information
and intall instructions can be found on the official NumPy website \footnote{
\href{http://numpy.scipy.org/}{http://numpy.scipy.org/}
}.
Sage and FemHUB are shipped with current versions of NumPy.

The project is still in an active development process, and release
new versions in an regular basis (The last release before I started to
writing this report is 2 Months old)

For people who are familiar with Matlab I recommend the
online equivalence list between Matlab and Numpy from \emph{Mathesaurus} \footnote{
\href{http://mathesaurus.sourceforge.net/matlab-numpy.html}{http://mathesaurus.sourceforge.net/matlab-numpy.html}
}
for the first steps with NumPy.


\subsection{How to load Numpy}

To import numpy into Python simply write:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\end{Verbatim}

You can also import the whole namespace via \code{*}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

\textbf{Remark} I personally don't recommend to load the complete
nammespace, or the complete package, except for testing, due to
performance reasons. (This is somehow obvious because NumPy is
a rather big module)


\subsection{Numpy arrays}

The NumPy \emph{array} class is rather similar to Python \emph{lists}.
It's the basic datatype for many numerical tools in Python.


\subsubsection{Array Creation}

To create an \emph{array} we have to import it from NumPy first:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{array}
\end{Verbatim}

An \emph{array} can be created from different Python sequence types like
\emph{lists} or tuples. For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{l} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{array}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}
\PYG{g+go}{array([1, 2, 3])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{array}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{g+go}{array([1, 2, 3])}
\end{Verbatim}

\textbf{Remark} It is not clerly specified by the documention which other
containers may work (I guess the reason for this is that the
constructor is written in a quite generic way. The Python way to find
out if it work with other tzpes would be testing it out,

The intention of the NumPy developers was to give a Matlab like
feeling. So Many ways should be quite familiar for Matlab users:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{zeros}\PYG{p}{,} \PYG{n}{ones}\PYG{p}{,} \PYG{n}{eye}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy.random} \PYG{k+kn}{import} \PYG{n}{rand}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{array([ 0.,  0.,  0.])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{array([ 1.,  1.,  1.,  1.])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{array([[ 1.,  0.],}
\PYG{g+go}{      [ 0.,  1.]])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{array([ 0.62475625,  0.97783392,  0.7785848 ,  0.15707817])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}      \PYG{c}{\#create matrix}
\PYG{g+go}{array([[ 0.,  0.],}
\PYG{g+go}{       [ 0.,  0.]])}
\end{Verbatim}

A NumPy array can hold numbers of specific data types. To check which
datatype an array holds, one has to simply check the \code{dtype}
member:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{l} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{l}\PYG{o}{.}\PYG{n}{dtype}
\PYG{g+go}{dtype('int64')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{l2} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{l2}\PYG{o}{.}\PYG{n}{dtype}
\PYG{g+go}{dtype('float64')}
\end{Verbatim}

As one can see, the default datatpe for integers is \code{int64},
while for floating point numbers it is \code{float64} (because it is
a 64 bit system I am working on). But there are some more:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{float32}  \PYG{c}{\#single precision}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{float64}  \PYG{c}{\#double precision}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{float128} \PYG{c}{\#long double}

\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{int16}  \PYG{c}{\#16 Bit integer}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{int32}  \PYG{c}{\#32 Bit integer}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{int64}  \PYG{c}{\#64 Bit integer}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{int128} \PYG{c}{\#128 Bit Integer}
\end{Verbatim}

To create an array with a specific data type, you only have to
specify this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{int32}\PYG{p}{)}
\PYG{g+go}{array([2, 3], dtype=int32)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{int32}\PYG{p}{)}  \PYG{c}{\#using keyword argument}
\PYG{g+go}{array([2, 3], dtype=int32)}
\end{Verbatim}

But these aren't all possible datatypes. NumPy support also other
types, and the number is still growing, since it is under development.

There are several other ways to create arrays. See
the NumPy documentation \footnote{
\href{http://docs.scipy.org/doc/numpy-1.5.x/user/basics.creation.html\#arrays-creation}{http://docs.scipy.org/doc/numpy-1.5.x/user/basics.creation.html\#arrays-creation}
}, \footnote{
\href{http://docs.scipy.org/doc/numpy-1.5.x/reference/routines.array-creation.html\#routines-array-creation}{http://docs.scipy.org/doc/numpy-1.5.x/reference/routines.array-creation.html\#routines-array-creation}
} for further details.


\subsection{Artithmetics with NumPy arrays}

Since operators can be overloaded (see ::ref::\emph{overload\_ref} , NumPy supports also arithmetics
with \emph{arrays}. Note that all operations are elementwise.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{n}{b} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{5.}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}   \PYG{c}{\# Create vectors}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
\PYG{g+go}{array([ 7.,  9.])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{-} \PYG{n}{b}
\PYG{g+go}{array([-3., -3.])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\PYG{g+go}{array([ 10.,  18.])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{/} \PYG{n}{b}
\PYG{g+go}{array([ 0.4,  0.5])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{*}\PYG{o}{*} \PYG{n}{b}
\PYG{g+go}{array([  32.,  729.])}
\end{Verbatim}

To calculate the scalar product one has to use the \code{dot} function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{dot}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{28.0}
\end{Verbatim}

With the help of dot you can also calculate the matrix vector
product:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A} \PYG{o}{=} \PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A}
\PYG{g+go}{array([[ 1.,  1.],}
\PYG{g+go}{       [ 1.,  1.]])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{array([ 5.,  5.])}
\end{Verbatim}


\subsection{Applying functions elementwise}

NumPy also holds a lot of standard functions for elementwise
operations:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{sin}\PYG{p}{,} \PYG{n}{cos}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{sin}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{array([ 0.90929743,  0.14112001])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{array([-0.41614684, -0.9899925 ])}
\end{Verbatim}

(see the NumPy reference guide for further information \footnote{
\href{http://docs.scipy.org/doc/numpy/reference/routines.math.html}{http://docs.scipy.org/doc/numpy/reference/routines.math.html}
})

To create your own customized elementwise functions use the \code{vectorize} class in
NumPy. It takes a Python function for construction of the object, and
vectorize it.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{vectrorize}\PYG{p}{,} \PYG{n}{array}
\PYG{k+kn}{from} \PYG{n+nn}{numpy.random} \PYG{k+kn}{import} \PYG{n}{randn}

\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}sign}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if}  \PYG{n}{x} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{1}
    \PYG{k}{elif} \PYG{n}{x} \PYG{o}{\textless{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{o}{-}\PYG{l+m+mi}{1}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mi}{0}

\PYG{n}{vec\PYGZus{}abs} \PYG{o}{=} \PYG{n}{vectorize}\PYG{p}{(}\PYG{n}{my\PYGZus{}sign}\PYG{p}{)}
\end{Verbatim}

Then we get:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{vec} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{n}{vec}
\PYG{g+go}{array([ 1.2577085 ,  0.71063021,  1.41130699,  1.72412141, -1.18530781,}
\PYG{g+go}{        0.19527091, -0.20557102, -0.33562998, -1.5370958 , -0.47241905])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{vec\PYGZus{}abs}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{)}
\PYG{g+go}{array([ 1,  1,  1,  1, -1,  1, -1, -1, -1, -1])}
\end{Verbatim}


\section{SciPy}

SciPy is a module for scientific computing. It is based on NumPy and
holds a lot of extensions and algorithms. In fact NumPy is subsumed
in SciPy already.
It contains a lot of functionality which is contained in Matlab.

I will explain some scientific tools in detail, which are of common
interest.


\subsection{Linear Algebra}

For doing linear algebra with SciPy I would prefer to point at the
SciPy documentation, because it is much more detailed \footnote{
\href{http://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html}{http://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html}
}


\subsection{Sparse Linear Algebra}

There are several types of sparse matrices. Each of them has several
attributes and is used for different tasks.
I introduce here the ones I use the most, and some other important
features like the LinearOperator class.


\subsubsection{LIL (List of Lists)}

LIL matrices are made for creating sparse matrices.
To create a LIL matrix simply import the class and call the
constructor:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy.sparse} \PYG{k+kn}{import} \PYG{n}{lil\PYGZus{}matrix}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A} \PYG{o}{=} \PYG{n}{lil\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Now we can fill the entries like we do it normally with numpy vectors:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{rand}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{100}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;} \PYG{n}{A}
\PYG{g+go}{\textless{}1000x1000 sparse matrix of type '\textless{}type 'numpy.float64'\textgreater{}'}
\PYG{g+go}{      with 100 stored elements in LInked List format\textgreater{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;} \PYG{n}{A}
\PYG{g+go}{\textless{}1000x1000 sparse matrix of type '\textless{}type 'numpy.float64'\textgreater{}'}
\PYG{g+go}{      with 500 stored elements in LInked List format\textgreater{}}

\PYG{g+go}{and of course call the entries directly::}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{0.85312312525865719}
\end{Verbatim}

LIL matrices are not suited for arithmetics or vector operations but
for creating other sparse matrices. To convert it into an other sparse
type simply call the converting methods. Lets convert it for example
to CSC ( Compressed Sparse Column matrix) format:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A\PYGZus{}csc} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{tocsc}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A\PYGZus{}csc}
\PYG{g+go}{\textless{}1000x1000 sparse matrix of type '\textless{}type 'numpy.float64'\textgreater{}'}
\PYG{g+go}{      with 500 stored elements in Compressed Sparse Column format\textgreater{}}
\end{Verbatim}

To convert it back to a numpy vector simply call:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[ 0.16568301,  0.85841039,  0.58243887, ...,  0.        ,}
\PYG{g+go}{         0.        ,  0.        ],}
\PYG{g+go}{       [ 0.        ,  0.85312313,  0.33507849, ...,  0.        ,}
\PYG{g+go}{         0.        ,  0.        ],}
\PYG{g+go}{       [ 0.        ,  0.97454761,  0.16457123, ...,  0.        ,}
\PYG{g+go}{         0.        ,  0.        ],}
\PYG{g+go}{       ...,}
\PYG{g+go}{       [ 0.        ,  0.        ,  0.        , ...,  0.        ,}
\PYG{g+go}{         0.        ,  0.        ],}
\PYG{g+go}{       [ 0.        ,  0.        ,  0.        , ...,  0.        ,}
\PYG{g+go}{         0.        ,  0.        ],}
\PYG{g+go}{       [ 0.        ,  0.        ,  0.        , ...,  0.        ,}
\PYG{g+go}{         0.        ,  0.        ]])}
\end{Verbatim}


\subsubsection{CSC (Compressed Sparse Column) matrix}

CSC matrices are quite often used because they can perform matrix
vector multiplication quite efficiently. To create a CSC matrix either
do it with a LIL matrix like in the LIL matrix section before, or
create it with three arrays which contain the necessary data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy.sparse} \PYG{k+kn}{import} \PYG{n}{csc\PYGZus{}matrix}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{array}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rows} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cols} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{B} \PYG{o}{=} \PYG{n}{csc\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{p}{(}\PYG{n}{rows}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{shape} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{B}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[1, 5, 0],}
\PYG{g+go}{       [0, 0, 4],}
\PYG{g+go}{       [3, 0, 2]])}
\end{Verbatim}

Another variant would be the standard CSC representation. There are
three arrays: an index\_pointer array, an indices array, and a data
array. The row indices  for the ::math::\emph{i} th row are stored in
\code{indices{[}index\_pointer{[}i{]},index\_pointer{[}i+1{]}{]}}, while their
corresponding data is stored in
\code{data{[}index\_pointer{[}i{]}:index\_pointer{[}i+1{]}{]}}.
So the \code{index\_pointer} tells where to start and to stop
while going throug the indices and data lists. For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{indptr} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{indices} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{data} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{csc\PYGZus{}matrix}\PYG{p}{(} \PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{indices}\PYG{p}{,}\PYG{n}{indptr}\PYG{p}{)}\PYG{p}{,} \PYG{n}{shape}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{)}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[1, 0, 4],}
\PYG{g+go}{       [0, 0, 5],}
\PYG{g+go}{       [2, 3, 6]])}
\end{Verbatim}

Other possible ways would be generating the matrix with another
sparse matrix or an dense 2D array with the data as constructing
data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{csc\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\textless{}2x2 sparse matrix of type '\textless{}type 'numpy.int32'\textgreater{}'}
\PYG{g+go}{        with 2 stored elements in Compressed Sparse Column format\textgreater{}}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{csc\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[0, 1],}
\PYG{g+go}{       [1, 0]])}
\end{Verbatim}


\subsubsection{...and more}

To get more information on sparse matrices and their class methods
consult the scipy reference guide \footnote{
\href{http://docs.scipy.org/doc/scipy/reference/sparse.html}{http://docs.scipy.org/doc/scipy/reference/sparse.html}
}


\subsubsection{The LinearOperator class and iterative solvers}

The LinearOperator class allows to define abstract linear mappings,
which are not necessarily matrices. A linear operator only consists of
a tuple which represents the shape, and a matrix-vector
multiplication:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}matvec}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{a} \PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{... }    \PYG{n}{x}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{... }    \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{x}
\PYG{g+gp}{...}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy.sparse.linalg} \PYG{k+kn}{import} \PYG{n}{LinearOperator}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{lin} \PYG{o}{=} \PYG{n}{LinearOperator}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{matvec}\PYG{o}{=}\PYG{n}{my\PYGZus{}matvec}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{lin}\PYG{o}{.}\PYG{n}{matvec}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{array([3, 2, 1])}
\end{Verbatim}

The matrix vector multiplication can also be called with the \emph{*} operator:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{lin}\PYG{o}{*}\PYG{n}{x}
\PYG{g+go}{array([1, 2, 3])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{lin} \PYG{o}{*} \PYG{n}{x}
\PYG{g+go}{array([3, 2, 1])}
\end{Verbatim}

LinearOperators can be created from arrays, matrices or sparse
matrices with the \emph{aslinearoperator} function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy.sparse.linalg} \PYG{k+kn}{import} \PYG{n}{aslinearoperator}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A\PYGZus{}lin} \PYG{o}{=} \PYG{n}{aslinearoperator}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A\PYGZus{}lin}\PYG{o}{.}\PYG{n}{matvec}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{array([4, 0, 0])}
\end{Verbatim}

The LinearOperator class is mostly used for iterative Kylov solvers. Those
methods can be found in the \emph{scipy.sparse.linalg}. For example the
CG algorithm:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy.sparse.linalg} \PYG{k+kn}{import} \PYG{n}{cg}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{A\PYGZus{}lin}\PYG{o}{*}\PYG{n}{sol}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{array([ 3.,  2.,  1.])}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}
\PYG{g+go}{array([3, 2, 1])}
\end{Verbatim}

For more information see again the SciPy reference \footnote{
\href{http://docs.scipy.org/doc/scipy/reference/sparse.linalg.html}{http://docs.scipy.org/doc/scipy/reference/sparse.linalg.html}
}
\hypertarget{weave-ref}{}

\section{Weave}

Weave is included in SciPy and a tool for writing inline C++ with
weave for speedup your code. I give here a short example how to use
Weave.

Consider band-matrix vector multiplication:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{band\PYGZus{}matvec\PYGZus{}py}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{result} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{u}\PYG{o}{.}\PYG{n}{dtype}\PYG{p}{)}


    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{-}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]}
            \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

This is not very fast:

\begin{Verbatim}[commandchars=@\[\]]
sage: import numpy
sage: datatype = numpy.float64
sage: N = 2**14
sage: B = 2**6
sage: A = rand(B,N).astype(datatype)
sage: @%timeit band@_matvec@_py(A,u)
5 loops, best of 3: 3.48 s per loop

The reason for this is that array access is quite costly
in Python. A possibility to make that better would be to write
C++ code inline with the Weave module. To do that give the Python
Interpreter your C++ code as string, and then let compile it. Here
an implementation of the band-matrix vector multiplication with weave::

from numpy import array, zeros
from scipy.weave import converters
from scipy import weave

def band@_matvec@_inline(A,u):

    result = zeros(u.shape@PYGZlb[]0@PYGZrb[],dtype=u.dtype)

    N = A.shape@PYGZlb[]1@PYGZrb[]
    B = A.shape@PYGZlb[]0@PYGZrb[]

    code = """
    for(int i=0; i @textless[] N;i++)
    {
      result(i) = A(0,i)*u(i);
    }
    for(int j=1;j @textless[] B;j++)
    {

        for(int i=0; i @textless[] (N-j);i++)
        {
          if((i+j @textless[] N))
          {
            result(i) += A(j,i)*u(j+i);
            result(i+j) += A(j,i)*u(i);
          }

        }

    }
    """

    weave.inline(code,@PYGZlb[]'u', 'A', 'result', 'N', 'B'@PYGZrb[],
               type@_converters=converters.blitz)
    return result
\end{Verbatim}

As it can be seen the syntax is not that different from Numpy. The
reason for this is, that Weave uses here the Blitz library for
numerical computation, which has it's own vector class.

If you call this function the first time it will be compiled in
runtime:

\begin{Verbatim}[commandchars=@\[\]]
sage: band@_matvec@_inline(A,u)
creating /tmp/maldun/python26@_intermediate/compiler@_2da6387b1d12110fba46fe47fea9326a
In file included from /home/maldun/sage/sage-4.6.1/local/lib/python2.6/site-packages/scipy/weave/blitz/blitz/array-impl.h:37,
                 from /home/maldun/sage/sage-4.6.1/local/lib/python2.6/site-packages/scipy/weave/blitz/blitz/array.h:26,
                 from /home/maldun/.python26@_compiled/sc@_7f8ca882b38e1f398003844545921f4a0.cpp:11:
/home/maldun/sage/sage-4.6.1/local/lib/python2.6/site-packages/scipy/weave/blitz/blitz/range.h: In member function bool blitz::Range::isAscendingContiguous() const:
/home/maldun/sage/sage-4.6.1/local/lib/python2.6/site-packages/scipy/weave/blitz/blitz/range.h:120: warning: suggest parentheses around @&@& within @textbar[]@textbar[]
array(@PYGZlb[]-7.03708979, -0.53476595, -7.52383126, ...,  1.18391403,
        2.27257052,  0.39116477@PYGZrb[])
\end{Verbatim}

The next time you call it, the interpreter will use the compiled
program.
Let's test the speedup:

\begin{Verbatim}[commandchars=@\[\]]
sage: @%timeit band@_matvec@_inline(A,u)
25 loops, best of 3: 12.7 ms per loop
\end{Verbatim}

This was now about 270x faster than the original Python version.
For more information on using weave see either the documentation of
SciPy \footnote{
\href{http://www.scipy.org/Weave}{http://www.scipy.org/Weave}
} or the Sage tutorial on that topic \footnote{
\href{http://www.sagemath.org/doc/numerical\_sage/weave.html}{http://www.sagemath.org/doc/numerical\_sage/weave.html}
}.

\textbf{Note:} At the time I checked the Sage tutorial the last time
it was not updated and contain some mistakes. In the next version of
Sage (4.6.2) this should be corrected. See the Sage trac for a corrected
version \footnote{
\href{http://trac.sagemath.org/sage\_trac/ticket/9791}{http://trac.sagemath.org/sage\_trac/ticket/9791}
}
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-Cython}{}

\chapter{Cython}

Well Cython isn't a part of Python, it is a different language, but
very similar to Python, and in fact it is almost to 90\% compatible.
(It is stated that Cython is a superset of Python, but it's currently
under development so there are some features which are not supported yet!)

It first started with the Pyrex project, which allowed to compile
Python to C. The idea was to allow the user to declare C variables and
call C functions within Cython, and make it possible for the C
compiler
to compile the Python like code to fast C code.

Cython has bindings for NumPy, mpi4py and other Python modules to
support scientific computation.

Currently Cython only works on the CPython implementation, but there
are efforts to get it working in IronPython on .Net as well.

I will here give a short tutorial on Cython and demonstrate on an
example how to speed up your NumPy code.

\textbf{Important Note} I assume that you are using Linux as operating
system. If you use Windows or an other OS look up the Cython
documentation for specific details! \footnote{
\href{http://docs.cython.org/index.html}{http://docs.cython.org/index.html}
}


\section{How to compile your Cython Code}


\subsection{Sage}

This is the easiest way. Either write your Cython
code in a \emph{.spyx} (Sage Pyrex) file, or in the notebook, with the
magic function \code{\%cython}.

To use a \emph{.spyx} file simply load it into Sage with the \code{load}
command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{load} \PYG{n}{my\PYGZus{}cython\PYGZus{}file}\PYG{o}{.}\PYG{n}{spyx}
\end{Verbatim}

For example I write a short code snippet for an self made
scalar product:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{!=} \PYG{n}{y}\PYG{o}{.}\PYG{n}{size}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Mismatch}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mf}{0}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

I save this in the file my\_dot.spyx. Now I call Sage, and cd to the
directory I saved the file. Now simply call Sage, and type:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{load} \PYG{n}{my\PYGZus{}dot}\PYG{o}{.}\PYG{n}{spyx}
\PYG{n}{Compiling} \PYG{o}{.}\PYG{o}{/}\PYG{n}{my\PYGZus{}dot}\PYG{o}{.}\PYG{n}{spyx}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{Verbatim}

Now the function can be called directly like a normal Python
function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sage}\PYG{p}{:} \PYG{k}{from} \PYG{n+nn}{numpy} \PYG{k}{import} \PYG{n}{array}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{x} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{,}\PYG{l+m+mf}{2}\PYG{p}{,}\PYG{l+m+mf}{3.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{y} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{,}\PYG{l+m+mf}{0}\PYG{p}{,}\PYG{l+m+mf}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{l+m+mf}{16.0}
\end{Verbatim}

A different way would be in the notebook. Simply write in an
empty notebook cell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\%}\PYG{n}{cython}
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{!=} \PYG{n}{y}\PYG{o}{.}\PYG{n}{size}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Mismatch}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mf}{0}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

Now if you evalute it, the function will be compiled, and you can call
it normally.


\subsection{Setup files}

The direct approach in Python would be to write a setup file.
First write your code and save it to a \emph{.pyx} file. I use the
same code as before and write it to \emph{my\_dot.pyx}.

Now we use disutils and write a setup.py file, which works similar
to a make file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{distutils.core} \PYG{k}{import} \PYG{n}{setup}
\PYG{k}{from} \PYG{n+nn}{distutils.extension} \PYG{k}{import} \PYG{n}{Extension}
\PYG{k}{from} \PYG{n+nn}{Cython.Distutils} \PYG{k}{import} \PYG{n}{build\PYGZus{}ext}

\PYG{n}{setup}\PYG{p}{(}
    \PYG{n}{cmdclass} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{build\PYGZus{}ext}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{build\PYGZus{}ext}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{n}{ext\PYGZus{}modules} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Extension}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{my\PYGZus{}dot}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{my\PYGZus{}dot.pyx}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
\PYG{p}{)}
\end{Verbatim}

Save this as setup.py in the directory where your code file lies.

Now cd to your working directory where the code and setup file is
saved and call it with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{o}{-}\PYG{n}{build\PYGZus{}ext} \PYG{o}{-}\PYG{o}{-}\PYG{n}{inplace}
\end{Verbatim}

Then the \emph{.pyx} files will be compiled.
Now you can call it normally in Python (after changing to the working
directory):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{k}{from} \PYG{n+nn}{my\PYGZus{}dot} \PYG{k}{import} \PYG{n}{my\PYGZus{}dot}
\end{Verbatim}

To compile more files, simply put more extensions to the ext\_modules
list. I created for example a further file with the name \emph{test.pyx}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{distutils.core} \PYG{k}{import} \PYG{n}{setup}
\PYG{k}{from} \PYG{n+nn}{distutils.extension} \PYG{k}{import} \PYG{n}{Extension}
\PYG{k}{from} \PYG{n+nn}{Cython.Distutils} \PYG{k}{import} \PYG{n}{build\PYGZus{}ext}
\PYG{k}{import} \PYG{n+nn}{numpy}

\PYG{n}{setup}\PYG{p}{(}
    \PYG{n}{cmdclass} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{build\PYGZus{}ext}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{build\PYGZus{}ext}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{n}{ext\PYGZus{}modules} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Extension}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{my\PYGZus{}dot}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{my\PYGZus{}dot.pyx}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
                   \PYG{n}{Extension}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{test.pyx}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
\PYG{p}{)}
\end{Verbatim}

\textbf{Important:} If you import numpy as C library you have to add
\code{include\_dirs={[}numpy.get\_include(){]})} to the extension. In our
example this would look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{distutils.core} \PYG{k}{import} \PYG{n}{setup}
\PYG{k}{from} \PYG{n+nn}{distutils.extension} \PYG{k}{import} \PYG{n}{Extension}
\PYG{k}{from} \PYG{n+nn}{Cython.Distutils} \PYG{k}{import} \PYG{n}{build\PYGZus{}ext}
\PYG{k}{import} \PYG{n+nn}{numpy}

\PYG{n}{setup}\PYG{p}{(}
    \PYG{n}{cmdclass} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{build\PYGZus{}ext}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{build\PYGZus{}ext}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{n}{ext\PYGZus{}modules} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Extension}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{my\PYGZus{}dot}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{my\PYGZus{}dot.pyx}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{include\PYGZus{}dirs}\PYG{o}{=}\PYG{p}{[}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{get\PYGZus{}include}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
\PYG{p}{)}
\end{Verbatim}

I state this here, because it is not well documented in
the Cython docu, and I had to search it for long in Cython Mailing
list. How to import modules as C libraries will we see later.


\section{How to use Cython}

Here we look at the advanced syntax in Cython, and other features in Python.


\subsection{The \emph{cdef} statment}


\subsubsection{Type declaration}

\code{cdef} is used for C type declaration, and defining C functions.
This can be very useful for speeding up your Python programs.

Let's look at our scalar product again:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{!=} \PYG{n}{y}\PYG{o}{.}\PYG{n}{size}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Mismatch}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mf}{0}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

The counter variables cost a lot of efficiency because the program has
to check first, what it recieves, because in Python \code{i} could be
every type of object. To overcome this we tell Cython to take a normal
C integer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}

  \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{!=} \PYG{n}{y}\PYG{o}{.}\PYG{n}{size}
      \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Mismatch}\PYG{l+s}{"}\PYG{p}{)}

  \PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{result} \PYG{o}{=} \PYG{l+m+mf}{0}

  \PYG{k}{cdef} \PYG{k+kt}{int} \PYG{n+nf}{i}

  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

  \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

Now you can compile and use it. Let's measure the difference:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{x} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mf}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{6}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{y} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mf}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{6}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{o}{\%}\PYG{n}{timeit} \PYG{n}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{l+m+mf}{5} \PYG{n}{loops}\PYG{p}{,} \PYG{n}{best} \PYG{n}{of} \PYG{l+m+mf}{3}\PYG{p}{:} \PYG{l+m+mf}{1.1} \PYG{n}{s} \PYG{n}{per} \PYG{n}{loop}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{load} \PYG{n}{my\PYGZus{}dot}\PYG{o}{.}\PYG{n}{spyx}
\PYG{n}{Compiling} \PYG{o}{.}\PYG{o}{/}\PYG{n}{my\PYGZus{}dot}\PYG{o}{.}\PYG{n}{spyx}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{sage}\PYG{p}{:} \PYG{o}{\%}\PYG{n}{timeit} \PYG{n}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{l+m+mf}{5} \PYG{n}{loops}\PYG{p}{,} \PYG{n}{best} \PYG{n}{of} \PYG{l+m+mf}{3}\PYG{p}{:} \PYG{l+m+mf}{653} \PYG{n}{ms} \PYG{n}{per} \PYG{n}{loop}
\end{Verbatim}

We this was already twice as fast as the old version.
(I used a Pentium Dual Core with 1.8
GHz, and 2 GB Ram). This is not that much, but more is possible!

The next step would be to tell the function which data types to use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cimport} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{cnumpy}

\PYG{k}{ctypedef} \PYG{n}{cnumpy}\PYG{o}{.}\PYG{n}{float64\PYGZus{}t} \PYG{n}{reals} \PYG{c}{\#typedef\PYGZus{}for easier reedding}

\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{cnumpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim}\PYG{o}{=}\PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{x}\PYG{p}{,}
              \PYG{n}{cnumpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim}\PYG{o}{=}\PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{size} \PYG{o}{!=} \PYG{n}{y}\PYG{o}{.}\PYG{n}{size}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Mismatch}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{result} \PYG{o}{=} \PYG{l+m+mf}{0}

    \PYG{k}{cdef} \PYG{k+kt}{int} \PYG{n+nf}{i}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

In the first line we used the \code{cimport} statement to load the C version
of NumPy. (I explain cimport later)
Then we used the \code{ctypedef} statment to declare the float64 (double)
datatype as reals, so that we have to type less (like the typedef
statement in C).

The main difference in this example is that we told Cython that the
input should be to NumPy arrays. This avoids unecessary overhead. Now
we make the timing again:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{load} \PYG{n}{my\PYGZus{}dot}\PYG{o}{.}\PYG{n}{spyx}
\PYG{n}{Compiling} \PYG{o}{.}\PYG{o}{/}\PYG{n}{my\PYGZus{}dot}\PYG{o}{.}\PYG{n}{spyx}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{sage}\PYG{p}{:} \PYG{o}{\%}\PYG{n}{timeit} \PYG{n}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{l+m+mf}{125} \PYG{n}{loops}\PYG{p}{,} \PYG{n}{best} \PYG{n}{of} \PYG{l+m+mf}{3}\PYG{p}{:} \PYG{l+m+mf}{3.54} \PYG{n}{ms} \PYG{n}{per} \PYG{n}{loop}
\end{Verbatim}

This was now about 300x faster than the original version.

The drawback is that the Cython function only take numpy arrays:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mf}{5}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{y} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mf}{5}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n+ne}{TypeError}\PYG{p}{:} \PYG{n}{Argument} \PYG{l+s}{'}\PYG{l+s}{x}\PYG{l+s}{'} \PYG{n}{has} \PYG{n}{incorrect} \PYG{n+nb}{type} \PYG{p}{(}\PYG{n}{expected} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{got} \PYG{n+nb}{list}\PYG{p}{)}
\end{Verbatim}


\subsubsection{Declaring functions}

The \code{cdef} statement can also be used for defining functions. A
function that is defined by a \code{cdef} statment doesn't appear in the
namespace of the Python interpreter and can only be called within
other functions.

For example let's define a \code{cdef} function
\code{f}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{2} \PYG{o}{-} \PYG{n}{x}
\end{Verbatim}

If yould try now to call it Python won't find it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+ne}{NameError}\PYG{p}{:} \PYG{n}{name} \PYG{l+s}{'}\PYG{l+s}{f}\PYG{l+s}{'} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{defined}
\end{Verbatim}

But you can call it within an other function defined in a \emph{.pyx}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{call\PYGZus{}f}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

Another possibility would be the cpdef statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{2} \PYG{o}{-} \PYG{n}{x}
\end{Verbatim}

This function can now be called both ways.

\textbf{Note:} If you don't declare it, \code{cdef} functions can't handly
exceptions right. For example

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mf}{0}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Division by Zero!}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mf}{2}\PYG{p}{)} \PYG{o}{-} \PYG{n}{x}
\end{Verbatim}

would not raise a Python exception. To do this use the except
statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)} \PYG{k}{except} \PYG{o}{*}\PYG{p}{:}

    \PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mf}{0}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Division by Zero!}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mf}{2}\PYG{p}{)} \PYG{o}{-} \PYG{n}{x}
\end{Verbatim}

The \code{*} means that the function should propagate arbitrary
exceptions. To be more specific you can also handle specific output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)} \PYG{k}{except}\PYG{o}{?} \PYG{l+m+mf}{0}\PYG{p}{:}

  \PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mf}{0}\PYG{p}{:}
      \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Division by Zero!}\PYG{l+s}{"}\PYG{p}{)}

  \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mf}{2}\PYG{p}{)} \PYG{o}{-} \PYG{n}{x}
\end{Verbatim}

The \code{?} here means that \code{0} is accepted as output too (or else you
would recieve an error if \code{0} is returned)


\subsubsection{\texttt{cdef} classes}

Classes can also be defined with \code{cdef} also. Let's take the example
from the Cython documentation (see \footnote{
\href{http://docs.cython.org/src/tutorial/cdef\_classes.html}{http://docs.cython.org/src/tutorial/cdef\_classes.html}
}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k}{class} \PYG{n+nf}{Function}\PYG{p}{:}
    \PYG{k}{cpdef} \PYG{k+kt}{double} \PYG{n+nf}{evaluate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{double} \PYG{n}{x}\PYG{p}{)} \PYG{k}{except} \PYG{o}{*}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mf}{0}
\end{Verbatim}

A \code{cdef} class is also called Extension Type.

This class can be derived like a normal Python class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k}{class} \PYG{n+nf}{SinOfSquareFunction}\PYG{p}{(}\PYG{n}{Function}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{cpdef} \PYG{k+kt}{double} \PYG{n+nf}{evaluate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{double} \PYG{n}{x}\PYG{p}{)} \PYG{k}{except} \PYG{o}{*}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{2}\PYG{p}{)}
\end{Verbatim}

\code{cdef} classes are very limited in comparison to Python classes,
because C don't know classes, but only structs. (Since Cython 0.13 it
is possible to wrap C++ classes. See the Cython documentation for
further details \footnote{
\href{http://docs.cython.org/src/userguide/wrapping\_CPlusPlus.html}{http://docs.cython.org/src/userguide/wrapping\_CPlusPlus.html}
})

We can use this new class like a new datatype.
See again an example from the Cython documentation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{integrate}\PYG{p}{(}\PYG{n}{Function} \PYG{n}{f}\PYG{p}{,} \PYG{n}{double} \PYG{n}{a}\PYG{p}{,} \PYG{n}{double} \PYG{n}{b}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{cdef} \PYG{k+kt}{int} \PYG{n+nf}{i}
    \PYG{k}{cdef} \PYG{k+kt}{double} \PYG{n+nf}{s}\PYG{p}{,} \PYG{n+nf}{dx}
    \PYG{k}{if} \PYG{n}{f} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{f cannot be None}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mf}{0}
    \PYG{n}{dx} \PYG{o}{=} \PYG{p}{(}\PYG{n}{b}\PYG{o}{-}\PYG{n}{a}\PYG{p}{)}\PYG{o}{/}\PYG{n}{N}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{i}\PYG{o}{*}\PYG{n}{dx}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{s} \PYG{o}{*} \PYG{n}{dx}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{SinOfSquareFunction}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0}\PYG{p}{,} \PYG{l+m+mf}{1}\PYG{p}{,} \PYG{l+m+mf}{10000}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\subsection{Calling extern C functions}

In Cython it is possible to call functions from other C programs
defined in a header file. For example we want to wrap the sinus from
the math.h in a Python function. Then we would write for example in a
\emph{.pyx} file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kr}{extern} \PYG{k}{from} \PYG{l+s}{"}\PYG{l+s}{math.h}\PYG{l+s}{"}\PYG{p}{:}
  \PYG{n}{double} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{c\PYGZus{}sin}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

The \code{cdef extern} statement help us to call \code{sin} from C.
The \code{c\_sin} function only serves as a wrapper for us, because we
can't call a \code{cdef} function directly. If you want to call your
Python function with sin, you can rename the extern C function with
a custom made identifier:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kr}{extern} \PYG{k}{from} \PYG{l+s}{"}\PYG{l+s}{math.h}\PYG{l+s}{"}\PYG{p}{:}
    \PYG{n}{double} \PYG{n}{c\PYGZus{}sin} \PYG{l+s}{"}\PYG{l+s}{sin}\PYG{l+s}{"}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{c\PYGZus{}sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

The \code{c\_sin} is the name of the \code{cdef} function.

If you want to compile this file, you have to tell your compiler which
libraries you linked, because they are not linked automatically! In
this case it is the math library with abbreviation ``m''. You have to
specify this in your setup file (I saved the sinus to \emph{math\_stuff.pyx}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{distutils.core} \PYG{k}{import} \PYG{n}{setup}
\PYG{k}{from} \PYG{n+nn}{distutils.extension} \PYG{k}{import} \PYG{n}{Extension}
\PYG{k}{from} \PYG{n+nn}{Cython.Distutils} \PYG{k}{import} \PYG{n}{build\PYGZus{}ext}

\PYG{n}{setup}\PYG{p}{(}
    \PYG{n}{name} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Math Stuff}\PYG{l+s}{"}\PYG{p}{,}
    \PYG{n}{cmdclass} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{build\PYGZus{}ext}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{build\PYGZus{}ext}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{n}{ext\PYGZus{}modules} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Extension}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{math\PYGZus{}stuff}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{math\PYGZus{}stuff.pyx}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,}
                   \PYG{n}{libraries}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{m}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
    \PYG{c}{\#m for compiler flag -lm (math library)}
\PYG{p}{)}
\end{Verbatim}

If you use Sage you have to specify this directly in the \emph{.spyx} file
with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#clib m}
\end{Verbatim}

in our example this would look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#clib m}

\PYG{k}{cdef} \PYG{k+kr}{extern} \PYG{k}{from} \PYG{l+s}{"}\PYG{l+s}{math.h}\PYG{l+s}{"}\PYG{p}{:}
    \PYG{n}{double} \PYG{n}{c\PYGZus{}sin} \PYG{l+s}{"}\PYG{l+s}{sin}\PYG{l+s}{"}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{c\PYGZus{}sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

Another example: Let's link the scalar product from the BLAS
library:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cimport} \PYG{n+nn}{numpy}

\PYG{k}{ctypedef} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{float64\PYGZus{}t} \PYG{n}{reals} \PYG{c}{\#typedef\PYGZus{}for easier reedding}

\PYG{k}{cdef} \PYG{k+kr}{extern} \PYG{k}{from} \PYG{l+s}{"}\PYG{l+s}{cblas.h}\PYG{l+s}{"}\PYG{p}{:}
    \PYG{n}{double} \PYG{n}{ddot} \PYG{l+s}{"}\PYG{l+s}{cblas\PYGZus{}ddot}\PYG{l+s}{"}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{N}\PYG{p}{,} \PYG{n}{double} \PYG{o}{*}\PYG{n}{X}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{incX}\PYG{p}{,}\PYG{n}{double} \PYG{o}{*}\PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{incY}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{blas\PYGZus{}dot}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{x}\PYG{p}{,} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{ddot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\textless{}}\PYG{n}{reals}\PYG{o}{*}\PYG{o}{\textgreater{}}\PYG{n}{x}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{x}\PYG{o}{.}\PYG{n}{strides}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{reals}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\textless{}}\PYG{n}{reals}\PYG{o}{*}\PYG{o}{\textgreater{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{y}\PYG{o}{.}\PYG{n}{strides}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{reals}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

The blas implementation gives only a small improvement here (which is
not completely unexpected, because the algorithm is rather simple):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{x} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mf}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{6}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{n}{y} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mf}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{6}\PYG{p}{)}
\PYG{n}{sage}\PYG{p}{:} \PYG{o}{\%}\PYG{n}{timeit} \PYG{n}{my\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{l+m+mf}{125} \PYG{n}{loops}\PYG{p}{,} \PYG{n}{best} \PYG{n}{of} \PYG{l+m+mf}{3}\PYG{p}{:} \PYG{l+m+mf}{3.55} \PYG{n}{ms} \PYG{n}{per} \PYG{n}{loop}
\PYG{n}{sage}\PYG{p}{:} \PYG{o}{\%}\PYG{n}{timeit} \PYG{n}{blas\PYGZus{}dot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{l+m+mf}{125} \PYG{n}{loops}\PYG{p}{,} \PYG{n}{best} \PYG{n}{of} \PYG{l+m+mf}{3}\PYG{p}{:} \PYG{l+m+mf}{3.05} \PYG{n}{ms} \PYG{n}{per} \PYG{n}{loop}
\end{Verbatim}


\subsection{\texttt{cimport} and .pxd files}

\emph{.pxd} are like \emph{.h} files in C. They can be used for sharing external
C declarations, or functions that are suited for inlining by the C compiler.

Functions that are declared inline in \emph{.pxd} files can be imported with the
\code{cimport} statement.

For example let's add a function which calculates the square root of
a number to the \emph{math\_stuff.pyx} from earlier, where the operation
itelf is called as inline function from C. We write the inline
function to the file \emph{math\_stuff.pxd}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kr}{inline} \PYG{k+kt}{double} \PYG{n+nf}{inl\PYGZus{}sqrt}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\end{Verbatim}

We can now load this function from a \emph{.pyx} file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{double} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{inl\PYGZus{}sqrt}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

You can also save the extern definition of the BLAS scalar product to
a \emph{.pxd} file and can \code{cimport} it from there.

Here the \emph{blas.pxd} file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cdef} \PYG{k+kr}{extern} \PYG{k}{from} \PYG{l+s}{"}\PYG{l+s}{cblas.h}\PYG{l+s}{"}\PYG{p}{:}
    \PYG{n}{double} \PYG{n}{ddot} \PYG{l+s}{"}\PYG{l+s}{cblas\PYGZus{}ddot}\PYG{l+s}{"}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{N}\PYG{p}{,} \PYG{n}{double} \PYG{o}{*}\PYG{n}{X}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{incX}\PYG{p}{,}\PYG{n}{double} \PYG{o}{*}\PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{incY}\PYG{p}{)}
\end{Verbatim}

and here the addition to the math\_stuff.pyx:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cimport} \PYG{n+nn}{numpy}

\PYG{k}{from} \PYG{n+nn}{blas} \PYG{k}{cimport} \PYG{n}{ddot}
\PYG{k}{ctypedef} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{float64\PYGZus{}t} \PYG{n}{reals} \PYG{c}{\#typedef\PYGZus{}for easier reedding}

\PYG{k}{cpdef} \PYG{n+nf}{dot}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{x}\PYG{p}{,} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{ddot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\textless{}}\PYG{n}{reals}\PYG{o}{*}\PYG{o}{\textgreater{}}\PYG{n}{x}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{x}\PYG{o}{.}\PYG{n}{strides}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/}
    \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{reals}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\textless{}}\PYG{n}{reals}\PYG{o}{*}\PYG{o}{\textgreater{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{y}\PYG{o}{.}\PYG{n}{strides}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]} \PYG{o}{/}\PYG{o}{/} \PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{reals}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

What is also possible is to declare prototypes in a \emph{.pxd} file like
in a C header, which can be linked more efficiently.

For example let's make a prototype of a function and a class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cpdef} \PYG{n+nf}{dot}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{x}\PYG{p}{,} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{y}\PYG{p}{)}

\PYG{k}{cdef} \PYG{k}{class} \PYG{n+nf}{Function}\PYG{p}{:}
    \PYG{k}{cpdef} \PYG{k+kt}{double} \PYG{n+nf}{evaluate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{double} \PYG{n}{x}\PYG{p}{)}
\end{Verbatim}


\subsection{Profiling}

Profiling is a way to analyse and optimize your Cython programs.
I only give the reference to a tutorial in the Cython documentation
here  \footnote{
\href{http://docs.cython.org/src/tutorial/profiling\_tutorial.html}{http://docs.cython.org/src/tutorial/profiling\_tutorial.html}
}
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-MPI4Py}{}

\chapter{MPI4Py}

MPI4Py is a Python module for calling the MPI API.
For more information and detailed documentation I refer to
the official MPI4Py documentation \footnote{
\href{http://mpi4py.scipy.org/docs/usrman/index.html}{http://mpi4py.scipy.org/docs/usrman/index.html}
}
Let's start with the MPI Hello World program in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{mpi4py} \PYG{k}{import} \PYG{n}{MPI}
\PYG{n}{comm} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{COMM\PYGZus{}WORLD}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{hello world}\PYG{l+s}{"}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{my rank is: }\PYG{l+s+si}{\%d}\PYG{l+s}{"}\PYG{o}{\%}\PYG{n}{comm}\PYG{o}{.}\PYG{n}{rank}\PYG{p}{)}
\end{Verbatim}

As it can be seen the API is quite similar to the normal MPI API in C.
First we save this file as \emph{mpi.py}.
To call now our parallized version of the Hello World program simply
call the Python Interpreter with MPI:

\begin{Verbatim}[commandchars=@\[\]]
@$ ./where/mpi/is/installed/mpirun -n @textless[]nr@_processes@textgreater[] python mpi.py
\end{Verbatim}

(If you use Sage, you have to install the openmpi package, and then you
can find mpirun in \code{SAGE\_LOCAL/bin/})
I for example use Sage, and this would look like this:

\begin{Verbatim}[commandchars=@\[\]]
@$ @$SAGE@_ROOT/local/bin/mpirun -n 4 sage -python mpi.py
hello world
my rank is: 2
hello world
my rank is: 0
hello world
my rank is: 1
hello world
my rank is: 3
\end{Verbatim}

Here another example: We generate an array with a thread which is
currently our main thread. Then we distribute it over all threads we
called:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{mpi4py} \PYG{k}{import} \PYG{n}{MPI}
\PYG{k}{import} \PYG{n+nn}{numpy}
\PYG{k}{import} \PYG{n+nn}{time}

\PYG{n}{comm} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{COMM\PYGZus{}WORLD}
\PYG{n}{rank} \PYG{o}{=} \PYG{n}{comm}\PYG{o}{.}\PYG{n}{rank}

\PYG{n}{sendbuf}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{root}\PYG{o}{=}\PYG{l+m+mf}{0}
\PYG{k}{if} \PYG{n}{rank}\PYG{o}{==}\PYG{l+m+mf}{0}\PYG{p}{:}
    \PYG{n}{m}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{comm}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,}\PYG{n}{comm}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
    \PYG{n}{sendbuf}\PYG{o}{=}\PYG{n}{m}
    \PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{v}\PYG{o}{=}\PYG{n}{MPI}\PYG{o}{.}\PYG{n}{COMM\PYGZus{}WORLD}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{sendbuf}\PYG{p}{,}\PYG{n}{root}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{rank}\PYG{p}{,}\PYG{l+s}{"}\PYG{l+s}{I got this array:}\PYG{l+s}{"}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{rank}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}

\PYG{n}{v}\PYG{o}{=}\PYG{n}{v}\PYG{o}{*}\PYG{l+m+mf}{2}

\PYG{n}{recvbuf}\PYG{o}{=}\PYG{n}{comm}\PYG{o}{.}\PYG{n}{gather}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{root}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{rank}\PYG{o}{==}\PYG{l+m+mf}{0}\PYG{p}{:}
  \PYG{n}{t2} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{print} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{recvbuf}\PYG{p}{)}
  \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{time:}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{(}\PYG{n}{t2}\PYG{o}{-}\PYG{n}{t1}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{1000}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{ ms }\PYG{l+s}{"}
\end{Verbatim}

This snippet produces this output:

\begin{Verbatim}[commandchars=@\[\]]
@$ @$SAGE@_ROOT/local/bin/mpirun -n 3 sage -python mpi@_scatter.py
@PYGZlb[]@PYGZlb[] -5.90596754e-04   4.21504158e-02   2.11213337e-01@PYGZrb[]
 @PYGZlb[]  9.67314022e-01  -2.16766512e+00   1.00552694e+00@PYGZrb[]
 @PYGZlb[]  1.37283086e+00  -2.29582623e-01   2.88653028e-01@PYGZrb[]@PYGZrb[]
(0, 'I got this array:')
(0, array(@PYGZlb[]-0.0005906 ,  0.04215042,  0.21121334@PYGZrb[]))
(1, 'I got this array:')
(1, array(@PYGZlb[] 0.96731402, -2.16766512,  1.00552694@PYGZrb[]))
(2, 'I got this array:')
(2, array(@PYGZlb[] 1.37283086, -0.22958262,  0.28865303@PYGZrb[]))
@PYGZlb[]@PYGZlb[] -1.18119351e-03   8.43008316e-02   4.22426674e-01@PYGZrb[]
 @PYGZlb[]  1.93462804e+00  -4.33533025e+00   2.01105389e+00@PYGZrb[]
 @PYGZlb[]  2.74566171e+00  -4.59165246e-01   5.77306055e-01@PYGZrb[]@PYGZrb[]
time: 3.59892845154  ms
\end{Verbatim}

For further examples I refer to the Sage tutorial for scientific
computing.  \footnote{
\href{http://www.sagemath.org/doc/numerical\_sage/mpi4py.html}{http://www.sagemath.org/doc/numerical\_sage/mpi4py.html}
}
\textbf{Note} The last time I checked the tutorial, it was outdated.
If you need a corrected version, I posted one on Sage trac \footnote{
\href{http://trac.sagemath.org/sage\_trac/attachment/ticket/10566/mpi4py.rst}{http://trac.sagemath.org/sage\_trac/attachment/ticket/10566/mpi4py.rst}
}.
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-PyCUDA}{}

\chapter{Python+CUDA = PyCUDA}

PyCUDA is a Python Interface for CUDA \footnote{
\href{http://www.nvidia.com/object/cuda\_home\_new.html}{http://www.nvidia.com/object/cuda\_home\_new.html}
}. It is currently in Alpha
Version, and was developed by Andreas Klckner \footnote{
\href{http://mathema.tician.de/software/pycuda}{http://mathema.tician.de/software/pycuda}
}

To use PyCUDA you have to install CUDA on your machine
\begin{description}
\item[\textbf{Note:} For using PyCUDA in Sage or FEMHub I created a PyCUDA] \leavevmode
package \footnote{
\href{http://trac.sagemath.org/sage\_trac/ticket/10010}{http://trac.sagemath.org/sage\_trac/ticket/10010}
}.

\end{description}

I will give here a short introduction how to use it. For more detailed
Information I refer to the documentation \footnote{
\href{http://documen.tician.de/pycuda/}{http://documen.tician.de/pycuda/}
} or the Wiki \footnote{
wikilink
}.


\section{Initialize PyCUDA}

There are two ways to initialize the PyCUDA driver. The first one is
to use the autoinit module:

import pycuda.autoinit

This makes the first device ready for use. Another possibility
is to manually initialize the device and create a context on this
device to use it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{import} \PYG{n+nn}{pycuda.driver} \PYG{k}{as} \PYG{n+nn}{cuda}
\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#init pycuda driver}
\PYG{n}{current\PYGZus{}dev} \PYG{o}{=} \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{Device}\PYG{p}{(}\PYG{n}{device\PYGZus{}nr}\PYG{p}{)} \PYG{c}{\#device we are working on}
\PYG{n}{ctx} \PYG{o}{=} \PYG{n}{current\PYGZus{}dev}\PYG{o}{.}\PYG{n}{make\PYGZus{}context}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#make a working context}
\PYG{n}{ctx}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#let context make the lead}

\PYG{c}{\#Code}

\PYG{n}{ctx}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#deactivate again}
\PYG{n}{ctx}\PYG{o}{.}\PYG{n}{detach}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#delete it}
\end{Verbatim}

This is useful if you are working on different devices. I will give
a more detailed example combined with MPI4Py lateron.
(See ::ref::\emph{mpi\_and\_pycuda\_ref})


\section{Get your CUDA code working in Python}

Similar to ::ref::\emph{weave\_ref} we can write CUDA code as string in
Python and then compile it with the NVCC. Here a short example:

First we initialize the driver, and import the needed modules:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{import} \PYG{n+nn}{pycuda.driver} \PYG{k}{as} \PYG{n+nn}{cuda}
\PYG{k}{import} \PYG{n+nn}{pycuda.autoinit}
\PYG{k}{import} \PYG{n+nn}{numpy}
\PYG{k}{from} \PYG{n+nn}{pycuda.compiler} \PYG{k}{import} \PYG{n}{SourceModule}
\end{Verbatim}

Then we write our Source code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{code} \PYG{o}{=} \PYG{l+s}{"""}
\PYG{l+s}{\PYGZus{}\PYGZus{}global\PYGZus{}\PYGZus{} void double\PYGZus{}array\PYGZus{}new(float *b, float *a, int *info)}
\PYG{l+s}{\PYGZob{}}
\PYG{l+s}{  int datalen = info[0];}

\PYG{l+s}{  for(int idx = threadIdx.x; idx \textless{} datalen; idx += blockDim.x)}
\PYG{l+s}{  \PYGZob{}}
\PYG{l+s}{    b[idx] = a[idx]*2;}
\PYG{l+s}{  \PYGZcb{}}
\PYG{l+s}{\PYGZcb{}}
\PYG{l+s}{"""}
\end{Verbatim}

And then write it to a source module:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mod} \PYG{o}{=} \PYG{n}{SourceModule}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}
\end{Verbatim}

The NVCC will now compile this code snippet. Now we can load the new
function to the Python namespace:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{func} \PYG{o}{=} \PYG{n}{mod}\PYG{o}{.}\PYG{n}{get\PYGZus{}function}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{double\PYGZus{}array\PYGZus{}new}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

Let's create some arrays for the functions, and load them on the card:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mf}{128}

\PYG{n}{a} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)}
\PYG{n}{info} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{n}{a\PYGZus{}gpu} \PYG{o}{=} \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{mem\PYGZus{}alloc}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{nbytes}\PYG{p}{)}
\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{memcpy\PYGZus{}htod}\PYG{p}{(}\PYG{n}{a\PYGZus{}gpu}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}

\PYG{n}{b\PYGZus{}gpu} \PYG{o}{=} \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{mem\PYGZus{}alloc}\PYG{p}{(}\PYG{n}{b}\PYG{o}{.}\PYG{n}{nbytes}\PYG{p}{)}
\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{memcpy\PYGZus{}htod}\PYG{p}{(}\PYG{n}{b\PYGZus{}gpu}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

\PYG{n}{info\PYGZus{}gpu} \PYG{o}{=} \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{mem\PYGZus{}alloc}\PYG{p}{(}\PYG{n}{info}\PYG{o}{.}\PYG{n}{nbytes}\PYG{p}{)}
\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{memcpy\PYGZus{}htod}\PYG{p}{(}\PYG{n}{info\PYGZus{}gpu}\PYG{p}{,} \PYG{n}{info}\PYG{p}{)}
\end{Verbatim}

Now we can call the function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{func}\PYG{p}{(}\PYG{n}{b\PYGZus{}gpu}\PYG{p}{,} \PYG{n}{a\PYGZus{}gpu}\PYG{p}{,}\PYG{n}{info\PYGZus{}gpu}\PYG{p}{,} \PYG{n}{block} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{32}\PYG{p}{,}\PYG{l+m+mf}{1}\PYG{p}{,}\PYG{l+m+mf}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grid} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{4}\PYG{p}{,}\PYG{l+m+mf}{1}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\textbf{Note:} The keyword \code{grid} is optional. If no grid is assigned,
it consists only of one block.

Now get the data back to the host, and print it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a\PYGZus{}doubled} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{empty\PYGZus{}like}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{memcpy\PYGZus{}dtoh}\PYG{p}{(}\PYG{n}{a\PYGZus{}doubled}\PYG{p}{,} \PYG{n}{b\PYGZus{}gpu}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{result:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{a\PYGZus{}doubled}
\end{Verbatim}

\textbf{Note:} To free the memory on the card use the free method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{free}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{b\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{free}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{info\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{free}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

PyCUDA has Garbage Collection, but it's still under developement. I
Therefore recommend it to free data after usage, just to be sure.

To create a Texture reference, to bind data to a texture on the
Graphic card. you have first to create one your source code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{code\PYGZus{}snippet} \PYG{o}{=} \PYG{l+s}{"""}
\PYG{l+s}{texture\textless{}float, 2\textgreater{} MyTexture;}
\PYG{l+s}{// Rest of Code}
\PYG{l+s}{"""}
\end{Verbatim}

Then compile it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{texture\PYGZus{}mode} \PYG{o}{=} \PYG{n}{SourceModule}\PYG{p}{(}\PYG{n}{code\PYGZus{}snippet}\PYG{p}{)}
\end{Verbatim}

and get it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{MyTexture} \PYG{o}{=} \PYG{n}{texture\PYGZus{}mode}\PYG{o}{.}\PYG{n}{get\PYGZus{}texref}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{MyTexture}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}


\section{The \texttt{gpuarray} class}

The \code{gpuarray} class provides a high level interface for doing
calculations with CUDA.
First import the gpuarray class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{k}{import} \PYG{n+nn}{pycuda.driver} \PYG{k}{as} \PYG{n+nn}{cuda}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{k}{import} \PYG{n+nn}{pycuda.autoinit}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{k}{from} \PYG{n+nn}{pycuda} \PYG{k}{import} \PYG{n}{gpuarray}
\end{Verbatim}

Creation of gpuarrays is quite easy. One way is to create a NumPy
array and convert it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{k}{from} \PYG{n+nn}{numpy.random} \PYG{k}{import} \PYG{n}{randn}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{k}{from} \PYG{n+nn}{numpy} \PYG{k}{import} \PYG{n}{float32}\PYG{p}{,} \PYG{n}{int32}\PYG{p}{,} \PYG{n}{array}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x} \PYG{o}{=} \PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mf}{5}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{float32}\PYG{p}{)}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x\PYGZus{}gpu} \PYG{o}{=} \PYG{n}{gpuarray}\PYG{o}{.}\PYG{n}{to\PYGZus{}gpu}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

You can print gpuarrays like you normally do:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mf}{0.24655211}\PYG{p}{,}  \PYG{l+m+mf}{0.00344609}\PYG{p}{,}  \PYG{l+m+mf}{1.45805557}\PYG{p}{,}  \PYG{l+m+mf}{0.22002029}\PYG{p}{,}  \PYG{l+m+mf}{1.28438667}\PYG{p}{]}\PYG{p}{)}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x\PYGZus{}gpu}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mf}{0.24655211}\PYG{p}{,}  \PYG{l+m+mf}{0.00344609}\PYG{p}{,}  \PYG{l+m+mf}{1.45805557}\PYG{p}{,}  \PYG{l+m+mf}{0.22002029}\PYG{p}{,}  \PYG{l+m+mf}{1.28438667}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

You can do normal calculations with the gpuarray:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{l+m+mf}{2}\PYG{o}{*}\PYG{n}{x\PYGZus{}gpu}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mf}{1.09917879}\PYG{p}{,}  \PYG{l+m+mf}{0.56061697}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{0.19573164}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{4.29430866}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{2.519032}  \PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{float32}\PYG{p}{)}

\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x\PYGZus{}gpu} \PYG{o}{+} \PYG{n}{x\PYGZus{}gpu}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mf}{1.09917879}\PYG{p}{,}  \PYG{l+m+mf}{0.56061697}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{0.19573164}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{4.29430866}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{2.519032}  \PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{float32}\PYG{p}{)}
\end{Verbatim}

or check attributes like with normal arrays:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x\PYGZus{}gpu}\PYG{p}{)}
\PYG{l+m+mf}{5}
\end{Verbatim}

\code{gpuarrays} also support slicing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x\PYGZus{}gpu}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{:}\PYG{l+m+mf}{3}\PYG{p}{]}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mf}{0.5495894} \PYG{p}{,}  \PYG{l+m+mf}{0.28030849}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{0.09786582}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{float32}\PYG{p}{)}
\end{Verbatim}

Unfortunatly they don't support indexing (yet):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x\PYGZus{}gpu}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n+ne}{ValueError}\PYG{p}{:} \PYG{n}{non}\PYG{o}{-}\PYG{n+nb}{slice} \PYG{n}{indexing} \PYG{o+ow}{not} \PYG{n}{supported}\PYG{p}{:} \PYG{l+m+mf}{1}
\end{Verbatim}

Be aware that a function which was created with a SourceModule, takes
an instance of \code{pycuda.driver.DeviceAllocation} and not a gpuarray.
But the content of the \code{gpuarray} is a \code{DeviceAllocation}. You can
get it with the attribute \code{gpudata}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{gpudata}
\PYG{o}{\textless{}}\PYG{n}{pycuda}\PYG{o}{.}\PYG{n}{\PYGZus{}driver}\PYG{o}{.}\PYG{n}{DeviceAllocation} \PYG{n+nb}{object} \PYG{n}{at} \PYG{l+m+mf}{0}\PYG{n}{x8c0d454}\PYG{o}{\textgreater{}}
\end{Verbatim}

Let's for example call the function from the section before:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{y\PYGZus{}gpu} \PYG{o}{=} \PYG{n}{gpuarray}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mf}{5}\PYG{p}{,}\PYG{n}{float32}\PYG{p}{)}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{info} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{5}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{int32}\PYG{p}{)}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{info\PYGZus{}gpu} \PYG{o}{=} \PYG{n}{gpuarray}\PYG{o}{.}\PYG{n}{to\PYGZus{}gpu}\PYG{p}{(}\PYG{n}{info}\PYG{p}{)}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{func}\PYG{p}{(}\PYG{n}{y\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{gpudata}\PYG{p}{,}\PYG{n}{x\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{gpudata}\PYG{p}{,}\PYG{n}{info\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{gpudata}\PYG{p}{,} \PYG{n}{block} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{32}\PYG{p}{,}\PYG{l+m+mf}{1}\PYG{p}{,}\PYG{l+m+mf}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grid} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{4}\PYG{p}{,}\PYG{l+m+mf}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{y\PYGZus{}gpu}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mf}{1.09917879}\PYG{p}{,}  \PYG{l+m+mf}{0.56061697}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{0.19573164}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{4.29430866}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{2.519032}  \PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{float32}\PYG{p}{)}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{l+m+mf}{2}\PYG{o}{*}\PYG{n}{x\PYGZus{}gpu}
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{-}\PYG{l+m+mf}{1.09917879}\PYG{p}{,}  \PYG{l+m+mf}{0.56061697}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{0.19573164}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{4.29430866}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mf}{2.519032}
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{float32}\PYG{p}{)}
\end{Verbatim}

\code{gpuarrays} can be bound to textures too:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textgreater{}\textgreater{}}\PYG{o}{\textgreater{}} \PYG{n}{x\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{bind\PYGZus{}to\PYGZus{}texref\PYGZus{}ext}\PYG{p}{(}\PYG{n}{MyTexture}\PYG{p}{)}
\end{Verbatim}
\hypertarget{mpi-and-pycuda-ref}{}

\section{Using MPI4Py and PyCUDA together}

I give here a short example how to use this, to get PyCUDA
working with MPI4Py. We initialize as many threads, as graphic
cards available (in this case 4) and do something on that devices.
Every thread is working on one device.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{mpi4py} \PYG{k}{import} \PYG{n}{MPI}
\PYG{k}{import} \PYG{n+nn}{pycuda.driver} \PYG{k}{as} \PYG{n+nn}{cuda}

\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#init pycuda driver}

\PYG{k}{from} \PYG{n+nn}{pycuda} \PYG{k}{import} \PYG{n}{gpuarray}
\PYG{k}{from} \PYG{n+nn}{numpy} \PYG{k}{import} \PYG{n}{float32}\PYG{p}{,} \PYG{n}{array}
\PYG{k}{from} \PYG{n+nn}{numpy.random} \PYG{k}{import} \PYG{n}{randn} \PYG{k}{as} \PYG{n}{rand}
\PYG{k}{import} \PYG{n+nn}{time}

\PYG{n}{comm} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{COMM\PYGZus{}WORLD}
\PYG{n}{rank} \PYG{o}{=} \PYG{n}{comm}\PYG{o}{.}\PYG{n}{rank}
\PYG{n}{root} \PYG{o}{=} \PYG{l+m+mf}{0}

\PYG{n}{nr\PYGZus{}gpus} \PYG{o}{=} \PYG{l+m+mf}{4}

\PYG{n}{sendbuf} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mf}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{20}\PYG{o}{*}\PYG{n}{nr\PYGZus{}gpus}
\PYG{n}{K} \PYG{o}{=} \PYG{l+m+mf}{1000}

\PYG{k}{if} \PYG{n}{rank} \PYG{o}{==} \PYG{l+m+mf}{0}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{rand}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{float32}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{16}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{x:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{x}

    \PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{sendbuf} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{nr\PYGZus{}gpus}\PYG{p}{,}\PYG{n}{N}\PYG{o}{/}\PYG{n}{nr\PYGZus{}gpus}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{rank} \PYG{o}{\textgreater{}} \PYG{n}{nr\PYGZus{}gpus}\PYG{o}{-}\PYG{l+m+mf}{1}\PYG{p}{:}
    \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{To few gpus!}\PYG{l+s}{"}\PYG{p}{)}


\PYG{n}{current\PYGZus{}dev} \PYG{o}{=} \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{Device}\PYG{p}{(}\PYG{n}{rank}\PYG{p}{)} \PYG{c}{\#device we are working on}
\PYG{n}{ctx} \PYG{o}{=} \PYG{n}{current\PYGZus{}dev}\PYG{o}{.}\PYG{n}{make\PYGZus{}context}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#make a working context}
\PYG{n}{ctx}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#let context make the lead}

\PYG{c}{\#recieve data and port it to gpu:}
\PYG{n}{x\PYGZus{}gpu\PYGZus{}part} \PYG{o}{=} \PYG{n}{gpuarray}\PYG{o}{.}\PYG{n}{to\PYGZus{}gpu}\PYG{p}{(}\PYG{n}{comm}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{sendbuf}\PYG{p}{,}\PYG{n}{root}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\#do something...}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{x\PYGZus{}gpu\PYGZus{}part} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{o}{*}\PYG{n}{x\PYGZus{}gpu\PYGZus{}part}

\PYG{c}{\#get data back:}
\PYG{n}{x\PYGZus{}part} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x\PYGZus{}gpu\PYGZus{}part}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ctx}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#deactivate again}
\PYG{n}{ctx}\PYG{o}{.}\PYG{n}{detach}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\#delete it}

\PYG{n}{recvbuf}\PYG{o}{=}\PYG{n}{comm}\PYG{o}{.}\PYG{n}{gather}\PYG{p}{(}\PYG{n}{x\PYGZus{}part}\PYG{p}{,}\PYG{n}{root}\PYG{p}{)} \PYG{c}{\#recieve data}

\PYG{k}{if} \PYG{n}{rank} \PYG{o}{==} \PYG{l+m+mf}{0}\PYG{p}{:}
    \PYG{n}{x\PYGZus{}doubled} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{n}{recvbuf}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
    \PYG{n}{t2} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{-}\PYG{n}{t1}

    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{doubled x:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{x\PYGZus{}doubled}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{time nedded:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{t2}\PYG{o}{*}\PYG{l+m+mf}{1000}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{ ms }\PYG{l+s}{"}
\end{Verbatim}
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-Example}{}

\chapter{An Example: Band-matrix vector multiplication}

We want to implement a band-matrix class for a symmetric band-matrix.
The constructor  takes an array as input, which holds the matrix
entries, of the lower part of the band matrix. See Wikipedia for
an Idea \footnote{
\href{http://en.wikipedia.org/wiki/Band\_matrix}{http://en.wikipedia.org/wiki/Band\_matrix}
}, and the IBM ESSL for precise details \footnote{
\href{http://publib.boulder.ibm.com/infocenter/clresctr/vxrx/index.jsp?topic=\%2Fcom.ibm.cluster.essl43.guideref.doc\%2Fam501\_upbsm.html}{http://publib.boulder.ibm.com/infocenter/clresctr/vxrx/index.jsp?topic=\%2Fcom.ibm.cluster.essl43.guideref.doc\%2Fam501\_upbsm.html}
}.

First we implement our class with several class methods, like
addition, and a matvec method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}band\PYGZus{}mat}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{M}\PYG{p}{,}\PYG{n}{beta} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{,}\PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{p}{(}\PYG{n}{d1}\PYG{p}{,}\PYG{n}{d2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}
    \PYG{p}{(}\PYG{n}{d3}\PYG{p}{,}\PYG{n}{d4}\PYG{p}{)} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{shape}

    \PYG{n}{d1} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{band\PYGZus{}width}
    \PYG{n}{d3} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{band\PYGZus{}width}

    \PYG{k}{if} \PYG{n}{d2} \PYG{o}{!=} \PYG{n}{d4}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{From \PYGZus{}rational\PYGZus{}krylov\PYGZus{}trigo\PYGZus{}band:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{                          Dimension Missmatch!}\PYG{l+s}{"}\PYG{p}{)}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{d1} \PYG{o}{\textless{}} \PYG{n}{d3}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{SYST} \PYG{o}{=} \PYG{n}{py\PYGZus{}band\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{d3}\PYG{p}{,}\PYG{n}{d4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{SYST}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{:}\PYG{n}{d1}\PYG{p}{,}\PYG{l+m+mf}{0}\PYG{p}{:}\PYG{n}{d2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{beta}\PYG{o}{*}\PYG{n}{A}\PYG{o}{.}\PYG{n}{data}\PYG{p}{;}
        \PYG{n}{SYST}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{data} \PYG{o}{+} \PYG{n}{SYST}\PYG{o}{.}\PYG{n}{data}\PYG{p}{;}
    \PYG{k}{elif} \PYG{p}{(}\PYG{n}{d1} \PYG{o}{\textgreater{}} \PYG{n}{d3}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{SYST} \PYG{o}{=} \PYG{n}{py\PYGZus{}band\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{d1}\PYG{p}{,}\PYG{n}{d2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{SYST}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{:}\PYG{n}{d3}\PYG{p}{,}\PYG{l+m+mf}{0}\PYG{p}{:}\PYG{n}{d4}\PYG{p}{]} \PYG{o}{=} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{data}\PYG{p}{;}
        \PYG{n}{SYST}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{SYST}\PYG{o}{.}\PYG{n}{data} \PYG{o}{+} \PYG{n}{beta}\PYG{o}{*}\PYG{n}{A}\PYG{o}{.}\PYG{n}{data}\PYG{p}{;}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{SYST} \PYG{o}{=}  \PYG{n}{py\PYGZus{}band\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{alpha}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{data} \PYG{o}{+} \PYG{n}{beta}\PYG{o}{*}\PYG{n}{A}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{SYST}

\PYG{k}{class} \PYG{n+nc}{band\PYGZus{}matrix}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{ab}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ab}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ab}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{ab}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{band\PYGZus{}width} \PYG{o}{=} \PYG{n}{ab}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dtype} \PYG{o}{=} \PYG{n}{ab}\PYG{o}{.}\PYG{n}{dtype}

    \PYG{k}{def} \PYG{n+nf}{matvec}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{pass}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{add\PYGZus{}band\PYGZus{}mat}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}
\end{Verbatim}

First we implement our matrix vector multiplication in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{band\PYGZus{}matvec\PYGZus{}py}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{result} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{u}\PYG{o}{.}\PYG{n}{dtype}\PYG{p}{)}


    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mf}{1}\PYG{p}{,}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}\PYG{o}{-}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]}
            \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

Then we derive our Python base class with the Python matrix vector
multiplication:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{py\PYGZus{}band\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{band\PYGZus{}matrix}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{matvec}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{u}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Missmatch!}\PYG{l+s}{"}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{band\PYGZus{}matvec\PYGZus{}py}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}
\end{Verbatim}

But this is quite slow. We can alternativly implement this Inline with weave:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{from} \PYG{n+nn}{numpy} \PYG{k}{import} \PYG{n}{array}\PYG{p}{,} \PYG{n}{zeros}
\PYG{k}{from} \PYG{n+nn}{scipy.weave} \PYG{k}{import} \PYG{n}{converters}
\PYG{k}{from} \PYG{n+nn}{scipy} \PYG{k}{import} \PYG{n}{weave}

\PYG{k}{def} \PYG{n+nf}{band\PYGZus{}matvec\PYGZus{}inline}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{result} \PYG{o}{=} \PYG{n}{zeros}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{u}\PYG{o}{.}\PYG{n}{dtype}\PYG{p}{)}

    \PYG{n}{N} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}
    \PYG{n}{B} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}

    \PYG{n}{code} \PYG{o}{=} \PYG{l+s}{"""}
\PYG{l+s}{    for(int i=0; i \textless{} N;i++)}
\PYG{l+s}{    \PYGZob{}}
\PYG{l+s}{      result(i) = A(0,i)*u(i);}
\PYG{l+s}{    \PYGZcb{}}
\PYG{l+s}{    for(int j=1;j \textless{} B;j++)}
\PYG{l+s}{    \PYGZob{}}

\PYG{l+s}{        for(int i=0; i \textless{} (N-j);i++)}
\PYG{l+s}{        \PYGZob{}}
\PYG{l+s}{          if((i+j \textless{} N))}
\PYG{l+s}{          \PYGZob{}}
\PYG{l+s}{            result(i) += A(j,i)*u(j+i);}
\PYG{l+s}{            result(i+j) += A(j,i)*u(i);}
\PYG{l+s}{          \PYGZcb{}}

\PYG{l+s}{        \PYGZcb{}}

\PYG{l+s}{    \PYGZcb{}}
\PYG{l+s}{    }\PYG{l+s}{"""}

    \PYG{n}{weave}\PYG{o}{.}\PYG{n}{inline}\PYG{p}{(}\PYG{n}{code}\PYG{p}{,}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{u}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{A}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{result}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{B}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,}
               \PYG{n}{type\PYGZus{}converters}\PYG{o}{=}\PYG{n}{converters}\PYG{o}{.}\PYG{n}{blitz}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

and create a new band matrix class:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{inline\PYGZus{}band\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{band\PYGZus{}matrix}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{matvec}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{u}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Missmatch!}\PYG{l+s}{"}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{band\PYGZus{}matvec\PYGZus{}inline}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}
\end{Verbatim}

or we implement the matrix vector product with Cython:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{cimport} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{cnumpy}
\PYG{k}{ctypedef} \PYG{n}{cnumpy}\PYG{o}{.}\PYG{n}{float64\PYGZus{}t} \PYG{n}{reals} \PYG{c}{\#typedef\PYGZus{}for easier reedding}

\PYG{k}{def} \PYG{n+nf}{band\PYGZus{}matvec\PYGZus{}c}\PYG{p}{(}\PYG{n}{cnumpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim}\PYG{o}{=}\PYG{l+m+mf}{2}\PYG{p}{]} \PYG{n}{A}\PYG{p}{,}\PYG{n}{cnumpy}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{[}\PYG{n}{reals}\PYG{p}{,}\PYG{n}{ndim}\PYG{o}{=}\PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{u}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{cdef} \PYG{k+kt}{Py\PYGZus{}ssize\PYGZus{}t} \PYG{n+nf}{i}\PYG{p}{,}\PYG{n+nf}{j}
    \PYG{k}{cdef} \PYG{k+kt}{cnumpy}.\PYG{k+kt}{ndarray}[\PYG{n+nf}{reals}\PYG{p}{,}\PYG{n+nf}{ndim}\PYG{o}{=}\PYG{l+m+mf}{1}\PYG{p}{]} \PYG{n}{result} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{A}\PYG{o}{.}\PYG{n}{dtype}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mf}{1}\PYG{p}{,}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{1}\PYG{p}{]}\PYG{o}{-}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]}
            \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]}\PYG{o}{+}\PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

and make the new band-matrix class analogously:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{c\PYGZus{}band\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{band\PYGZus{}matrix}\PYG{p}{)}\PYG{p}{:}
   \PYG{k}{def} \PYG{n+nf}{matvec}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{:}
       \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{u}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mf}{0}\PYG{p}{]}\PYG{p}{:}
           \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension Missmatch!}\PYG{l+s}{"}\PYG{p}{)}

       \PYG{k}{return} \PYG{n}{band\PYGZus{}matvec\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}
\end{Verbatim}

You can either import the band matrix base class to the \emph{.pyx} file
and define the derived Python class in the \emph{.pyx} file, or \code{cimport}
the function to a Python file with the new matrix class defined.

A more advanced example is an implementation in PyCUDA:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{import} \PYG{n+nn}{pycuda.driver} \PYG{k}{as} \PYG{n+nn}{cuda}
\PYG{k}{import} \PYG{n+nn}{pycuda.gpuarray} \PYG{k}{as} \PYG{n+nn}{gpuarray}

\PYG{k}{import} \PYG{n+nn}{pycuda.autoinit}
\PYG{k}{import} \PYG{n+nn}{numpy}
\PYG{k}{from} \PYG{n+nn}{pycuda.compiler} \PYG{k}{import} \PYG{n}{SourceModule}
\PYG{k}{from} \PYG{n+nn}{pycuda.driver} \PYG{k}{import} \PYG{n}{matrix\PYGZus{}to\PYGZus{}texref}

\PYG{k}{from} \PYG{n+nn}{numpy} \PYG{k}{import} \PYG{n}{array}\PYG{p}{,} \PYG{n}{zeros}\PYG{p}{,} \PYG{n}{int32}\PYG{p}{,} \PYG{n}{float32}\PYG{p}{,} \PYG{n}{intp}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sourceCodeTemplate} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{"}\PYG{l+s}{"}
\PYG{n}{texture}\PYG{o}{\textless{}}\PYG{k+kt}{float}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{\textgreater{}} \PYG{n}{matrixTexture}\PYG{p}{;}

\PYG{n}{\PYGZus{}\PYGZus{}global\PYGZus{}\PYGZus{}} \PYG{k+kt}{void} \PYG{n+nf}{gpu\PYGZus{}band\PYGZus{}matvec}\PYG{p}{(} \PYG{c+c1}{//\%(REALS)s *matrix,}
                                 \PYG{o}{\%}\PYG{p}{(}\PYG{n}{REALS}\PYG{p}{)}\PYG{n}{s} \PYG{o}{*}\PYG{n}{vector}\PYG{p}{,}
                                 \PYG{o}{\%}\PYG{p}{(}\PYG{n}{REALS}\PYG{p}{)}\PYG{n}{s} \PYG{o}{*}\PYG{n}{result}\PYG{p}{,}
                                 \PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{info}
                                 \PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{c+c1}{// Infos about matrix dimension}
  \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{dim} \PYG{o}{=} \PYG{n}{info}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
  \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{band\PYGZus{}with} \PYG{o}{=} \PYG{n}{info}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

  \PYG{c+c1}{// Infos about Blocks}

  \PYG{c+c1}{//unsigned int position = 0;}
  \PYG{k+kt}{int} \PYG{n}{idx} \PYG{o}{=} \PYG{n}{blockIdx}\PYG{p}{.}\PYG{n}{x} \PYG{o}{*} \PYG{n}{blockDim}\PYG{p}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;}

  \PYG{n}{\PYGZus{}\PYGZus{}shared\PYGZus{}\PYGZus{}} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{REALS}\PYG{p}{)}\PYG{n}{s} \PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{o}{\%}\PYG{p}{(}\PYG{n}{DOUBLE\PYGZus{}BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s}\PYG{p}{]}\PYG{p}{;}
  \PYG{o}{\%}\PYG{p}{(}\PYG{n}{REALS}\PYG{p}{)}\PYG{n}{s} \PYG{n}{result\PYGZus{}helper}\PYG{p}{;}

  \PYG{c+c1}{//\PYGZus{}\PYGZus{}syncthreads(); //Memory has to be loaded}

  \PYG{k}{while}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{\textless{}} \PYG{n}{dim} \PYG{o}{+}  \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s} \PYG{o}{*} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{NUMBER\PYGZus{}BLOCKS}\PYG{p}{)}\PYG{n}{s}\PYG{p}{)} \PYG{c+c1}{//While loop over all blocks}
  \PYG{p}{\PYGZob{}}

      \PYG{n}{\PYGZus{}\PYGZus{}syncthreads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Memory has to be loaded}

      \PYG{k}{if}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{\textless{}} \PYG{n}{dim}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
      \PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vector}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}\PYG{p}{;}


      \PYG{k}{if}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{+} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s} \PYG{o}{\textless{}} \PYG{n}{dim}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
        \PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{o}{+}\PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s}\PYG{p}{]} \PYG{o}{=}  \PYG{n}{vector}\PYG{p}{[}\PYG{n}{idx}\PYG{o}{+}\PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s}\PYG{p}{]}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{\PYGZus{}\PYGZus{}syncthreads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Memory has to be loaded}

      \PYG{n}{result\PYGZus{}helper} \PYG{o}{=} \PYG{n}{tex2D}\PYG{p}{(}\PYG{n}{matrixTexture}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{idx}\PYG{p}{)} \PYG{o}{*} \PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{p}{]}\PYG{p}{;}

      \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\textless{}} \PYG{n}{band\PYGZus{}with}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
         \PYG{n}{result\PYGZus{}helper} \PYG{o}{+}\PYG{o}{=} \PYG{n}{tex2D}\PYG{p}{(}\PYG{n}{matrixTexture}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{idx}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}

      \PYG{p}{\PYGZcb{}}


     \PYG{n}{\PYGZus{}\PYGZus{}syncthreads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Memory has to be loaded}

     \PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x} \PYG{o}{+} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{p}{]}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}

     \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{-} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\&}\PYG{o}{\&} \PYG{p}{(}\PYG{n}{idx} \PYG{o}{-} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s}\PYG{p}{)} \PYG{o}{\textless{}} \PYG{n}{dim}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
       \PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vector}\PYG{p}{[}\PYG{n}{idx} \PYG{o}{-} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s}\PYG{p}{]}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}

     \PYG{n}{\PYGZus{}\PYGZus{}syncthreads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Memory has to be loaded}

     \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\textless{}} \PYG{n}{band\PYGZus{}with}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{-} \PYG{n}{i} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\&}\PYG{o}{\&} \PYG{p}{(}\PYG{n}{idx} \PYG{o}{-} \PYG{n}{i} \PYG{o}{\textless{}} \PYG{n}{dim}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
          \PYG{n}{result\PYGZus{}helper} \PYG{o}{+}\PYG{o}{=} \PYG{n}{tex2D}\PYG{p}{(}\PYG{n}{matrixTexture}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{idx} \PYG{o}{-} \PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vector\PYGZus{}help}\PYG{p}{[}\PYG{n}{threadIdx}\PYG{p}{.}\PYG{n}{x} \PYG{o}{+} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s} \PYG{o}{-} \PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
     \PYG{p}{\PYGZcb{}}

     \PYG{k}{if}\PYG{p}{(}\PYG{n}{idx} \PYG{o}{\textless{}} \PYG{n}{dim}\PYG{p}{)}
     \PYG{p}{\PYGZob{}}
       \PYG{n}{result}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{=} \PYG{n}{result\PYGZus{}helper}\PYG{p}{;}
     \PYG{p}{\PYGZcb{}}


    \PYG{n}{idx} \PYG{o}{+}\PYG{o}{=} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{)}\PYG{n}{s} \PYG{o}{*} \PYG{o}{\%}\PYG{p}{(}\PYG{n}{NUMBER\PYGZus{}BLOCKS}\PYG{p}{)}\PYG{n}{s}\PYG{p}{;}

   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{l+s}{"}\PYG{l+s}{"}\PYG{l+s}{"}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{REALS} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{float}\PYG{l+s}{"}
\PYG{n}{BLOCK\PYGZus{}SIZE} \PYG{o}{=} \PYG{l+m+mi}{256}
\PYG{n}{NUMBER\PYGZus{}BLOCKS} \PYG{o}{=} \PYG{l+m+mi}{8}

\PYG{n}{sourceCode} \PYG{o}{=} \PYG{n}{sourceCodeTemplate} \PYG{o}{\%} \PYG{p}{\PYGZob{}}
\PYG{l+s}{'}\PYG{l+s}{REALS}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{REALS}\PYG{p}{,}
\PYG{l+s}{'}\PYG{l+s}{BLOCK\PYGZus{}SIZE}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{,}
\PYG{l+s}{'}\PYG{l+s}{DOUBLE\PYGZus{}BLOCK\PYGZus{}SIZE}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{,}
\PYG{l+s}{'}\PYG{l+s}{NUMBER\PYGZus{}BLOCKS}\PYG{l+s}{'}\PYG{p}{:} \PYG{n}{NUMBER\PYGZus{}BLOCKS}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{n}{matvec\PYGZus{}module} \PYG{o}{=} \PYG{n}{SourceModule}\PYG{p}{(}\PYG{n}{sourceCode}\PYG{p}{)}

\PYG{n}{matvec\PYGZus{}func} \PYG{o}{=} \PYG{n}{matvec\PYGZus{}module}\PYG{o}{.}\PYG{n}{get\PYGZus{}function}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{gpu\PYGZus{}band\PYGZus{}matvec}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{matrixTexture} \PYG{o}{=} \PYG{n}{matvec\PYGZus{}module}\PYG{o}{.}\PYG{n}{get\PYGZus{}texref}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{matrixTexture}\PYG{l+s}{"}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{band\PYGZus{}matrix} \PYG{k+kn}{import} \PYG{n}{add\PYGZus{}band\PYGZus{}mat}

\PYG{k}{class} \PYG{n+nc}{gpu\PYGZus{}band\PYGZus{}matrix}\PYG{p}{:}
  \PYG{l+s+sd}{"""variables for information about which matrix is}
\PYG{l+s+sd}{     currently on the texture}
\PYG{l+s+sd}{  """}

  \PYG{n}{nr\PYGZus{}matrices} \PYG{o}{=} \PYG{l+m+mi}{0}
  \PYG{n}{active\PYGZus{}matrix} \PYG{o}{=} \PYG{l+m+mi}{0}

  \PYG{l+s+sd}{"""Takes a numpy array"""}
  \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{data}\PYG{p}{,}\PYG{n}{set\PYGZus{}right} \PYG{o}{=} \PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}

      \PYG{k}{if} \PYG{n}{set\PYGZus{}right}\PYG{p}{:}
          \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{:}
              \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{j}\PYG{p}{:}\PYG{p}{,}\PYG{n}{N}\PYG{o}{-}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

      \PYG{c}{\#self.data = gpuarray.to\PYGZus{}gpu(data)}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{=} \PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{band\PYGZus{}with} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dtype} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{dtype}

      \PYG{n}{info} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{int32}\PYG{p}{)}

      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gpu\PYGZus{}info} \PYG{o}{=} \PYG{n}{gpuarray}\PYG{o}{.}\PYG{n}{to\PYGZus{}gpu}\PYG{p}{(}\PYG{n}{info}\PYG{p}{)}

      \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{matrix\PYGZus{}to\PYGZus{}texref}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{matrixTexture}\PYG{p}{,} \PYG{n}{order}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{F}\PYG{l+s}{"}\PYG{p}{)}

      \PYG{n}{gpu\PYGZus{}band\PYGZus{}matrix}\PYG{o}{.}\PYG{n}{nr\PYGZus{}matrices} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{identity\PYGZus{}nr} \PYG{o}{=} \PYG{n}{gpu\PYGZus{}band\PYGZus{}matrix}\PYG{o}{.}\PYG{n}{nr\PYGZus{}matrices}
      \PYG{n}{active\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{gpu\PYGZus{}band\PYGZus{}matrix}\PYG{o}{.}\PYG{n}{nr\PYGZus{}matrices}

  \PYG{k}{def} \PYG{n+nf}{matvec}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{x\PYGZus{}gpu}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{n}{x\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{size} \PYG{o}{!=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}
          \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Dimension mismatch!}\PYG{l+s}{"}\PYG{p}{)}

      \PYG{c}{\#self.data.bind\PYGZus{}to\PYGZus{}texref\PYGZus{}ext(matrixTexture,channels = 2)}
      \PYG{c}{\#cuda.matrix\PYGZus{}to\PYGZus{}texref(self.cpu\PYGZus{}data, matrixTexture, order="F")}

      \PYG{k}{if} \PYG{n}{gpu\PYGZus{}band\PYGZus{}matrix}\PYG{o}{.}\PYG{n}{active\PYGZus{}matrix} \PYG{o}{!=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{identity\PYGZus{}nr}\PYG{p}{:}
          \PYG{n}{cuda}\PYG{o}{.}\PYG{n}{matrix\PYGZus{}to\PYGZus{}texref}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{matrixTexture}\PYG{p}{,} \PYG{n}{order}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{F}\PYG{l+s}{"}\PYG{p}{)}
          \PYG{n}{gpu\PYGZus{}band\PYGZus{}matrix}\PYG{o}{.}\PYG{n}{active\PYGZus{}matrix} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{identity\PYGZus{}nr}

      \PYG{n}{y\PYGZus{}gpu}  \PYG{o}{=} \PYG{n}{gpuarray}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{x\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{n}{x\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{dtype}\PYG{p}{)}
      \PYG{n}{matvec\PYGZus{}func}\PYG{p}{(}\PYG{n}{intp}\PYG{p}{(}\PYG{n}{x\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{gpudata}\PYG{p}{)}\PYG{p}{,}\PYG{n}{intp}\PYG{p}{(}\PYG{n}{y\PYGZus{}gpu}\PYG{o}{.}\PYG{n}{gpudata}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{gpu\PYGZus{}info}\PYG{o}{.}\PYG{n}{gpudata}\PYG{p}{,} \PYG{n}{block} \PYG{o}{=} \PYG{p}{(}\PYG{n}{BLOCK\PYGZus{}SIZE}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grid}\PYG{o}{=} \PYG{p}{(}\PYG{n}{NUMBER\PYGZus{}BLOCKS}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
      \PYG{k}{return} \PYG{n}{y\PYGZus{}gpu}

  \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{return} \PYG{n}{add\PYGZus{}band\PYGZus{}mat}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}
\end{Verbatim}
\paragraph{Links}

\resetcurrentobjects
\hypertarget{--doc-License}{}

\hypertarget{license-ref}{}\chapter{Licenses}

To avoid the risk to get sued for nothing... but since everything is
open, there are no costs except copying them.


\section{License}

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS PUBLIC LICENSE (``CCPL'' OR ``LICENSE''). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS.
\begin{enumerate}
\item {} 
Definitions
\begin{enumerate}
\item {} 
``Adaptation'' means a work based upon the Work, or upon the Work and other pre-existing works, such as a translation, adaptation, derivative work, arrangement of music or other alterations of a literary or artistic work, or phonogram or performance and includes cinematographic adaptations or any other form in which the Work may be recast, transformed, or adapted including in any form recognizably derived from the original, except that a work that constitutes a Collection will not be considered an Adaptation for the purpose of this License. For the avoidance of doubt, where the Work is a musical work, performance or phonogram, the synchronization of the Work in timed-relation with a moving image (``synching'') will be considered an Adaptation for the purpose of this License.

\item {} 
``Collection'' means a collection of literary or artistic works, such as encyclopedias and anthologies, or performances, phonograms or broadcasts, or other works or subject matter other than works listed in Section 1(f) below, which, by reason of the selection and arrangement of their contents, constitute intellectual creations, in which the Work is included in its entirety in unmodified form along with one or more other contributions, each constituting separate and independent works in themselves, which together are assembled into a collective whole. A work that constitutes a Collection will not be considered an Adaptation (as defined below) for the purposes of this License.

\item {} 
``Creative Commons Compatible License'' means a license that is listed at \href{http://creativecommons.org/compatiblelicenses}{http://creativecommons.org/compatiblelicenses} that has been approved by Creative Commons as being essentially equivalent to this License, including, at a minimum, because that license: (i) contains terms that have the same purpose, meaning and effect as the License Elements of this License; and, (ii) explicitly permits the relicensing of adaptations of works made available under that license under this License or a Creative Commons jurisdiction license with the same License Elements as this License.

\item {} 
``Distribute'' means to make available to the public the original and copies of the Work or Adaptation, as appropriate, through sale or other transfer of ownership.

\item {} 
``License Elements'' means the following high-level license attributes as selected by Licensor and indicated in the title of this License: Attribution, ShareAlike.

\item {} 
``Licensor'' means the individual, individuals, entity or entities that offer(s) the Work under the terms of this License.

\item {} 
``Original Author'' means, in the case of a literary or artistic work, the individual, individuals, entity or entities who created the Work or if no individual or entity can be identified, the publisher; and in addition (i) in the case of a performance the actors, singers, musicians, dancers, and other persons who act, sing, deliver, declaim, play in, interpret or otherwise perform literary or artistic works or expressions of folklore; (ii) in the case of a phonogram the producer being the person or legal entity who first fixes the sounds of a performance or other sounds; and, (iii) in the case of broadcasts, the organization that transmits the broadcast.

\item {} 
``Work'' means the literary and/or artistic work offered under the terms of this License including without limitation any production in the literary, scientific and artistic domain, whatever may be the mode or form of its expression including digital form, such as a book, pamphlet and other writing; a lecture, address, sermon or other work of the same nature; a dramatic or dramatico-musical work; a choreographic work or entertainment in dumb show; a musical composition with or without words; a cinematographic work to which are assimilated works expressed by a process analogous to cinematography; a work of drawing, painting, architecture, sculpture, engraving or lithography; a photographic work to which are assimilated works expressed by a process analogous to photography; a work of applied art; an illustration, map, plan, sketch or three-dimensional work relative to geography, topography, architecture or science; a performance; a broadcast; a phonogram; a compilation of data to the extent it is protected as a copyrightable work; or a work performed by a variety or circus performer to the extent it is not otherwise considered a literary or artistic work.

\item {} 
``You'' means an individual or entity exercising rights under this License who has not previously violated the terms of this License with respect to the Work, or who has received express permission from the Licensor to exercise rights under this License despite a previous violation.

\item {} 
``Publicly Perform'' means to perform public recitations of the Work and to communicate to the public those public recitations, by any means or process, including by wire or wireless means or public digital performances; to make available to the public Works in such a way that members of the public may access these Works from a place and at a place individually chosen by them; to perform the Work to the public by any means or process and the communication to the public of the performances of the Work, including by public digital performance; to broadcast and rebroadcast the Work by any means including signs, sounds or images.

\item {} 
``Reproduce'' means to make copies of the Work by any means including without limitation by sound or visual recordings and the right of fixation and reproducing fixations of the Work, including storage of a protected performance or phonogram in digital form or other electronic medium.

\end{enumerate}

\item {} 
Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or restrict any uses free from copyright or rights arising from limitations or exceptions that are provided for in connection with the copyright protection under copyright law or other applicable laws.

\item {} 
License Grant. Subject to the terms and conditions of this License, Licensor hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for the duration of the applicable copyright) license to exercise the rights in the Work as stated below:
\begin{enumerate}
\item {} 
to Reproduce the Work, to incorporate the Work into one or more Collections, and to Reproduce the Work as incorporated in the Collections;

\item {} 
to create and Reproduce Adaptations provided that any such Adaptation, including any translation in any medium, takes reasonable steps to clearly label, demarcate or otherwise identify that changes were made to the original Work. For example, a translation could be marked ``The original work was translated from English to Spanish,'' or a modification could indicate ``The original work has been modified.'';

\item {} 
to Distribute and Publicly Perform the Work including as incorporated in Collections; and,

\item {} 
to Distribute and Publicly Perform Adaptations.

\item {} \begin{description}
\item[For the avoidance of doubt:] \leavevmode\begin{enumerate}
\item {} 
Non-waivable Compulsory License Schemes. In those jurisdictions in which the right to collect royalties through any statutory or compulsory licensing scheme cannot be waived, the Licensor reserves the exclusive right to collect such royalties for any exercise by You of the rights granted under this License;

\item {} 
Waivable Compulsory License Schemes. In those jurisdictions in which the right to collect royalties through any statutory or compulsory licensing scheme can be waived, the Licensor waives the exclusive right to collect such royalties for any exercise by You of the rights granted under this License; and,

\item {} 
Voluntary License Schemes. The Licensor waives the right to collect royalties, whether individually or, in the event that the Licensor is a member of a collecting society that administers voluntary licensing schemes, via that society, from any exercise by You of the rights granted under this License.

\end{enumerate}

\end{description}

\end{enumerate}

\end{enumerate}

The above rights may be exercised in all media and formats whether now known or hereafter devised. The above rights include the right to make such modifications as are technically necessary to exercise the rights in other media and formats. Subject to Section 8(f), all rights not expressly granted by Licensor are hereby reserved.
\begin{enumerate}
\item {} 
Restrictions. The license granted in Section 3 above is expressly made subject to and limited by the following restrictions:
\begin{enumerate}
\item {} 
You may Distribute or Publicly Perform the Work only under the terms of this License. You must include a copy of, or the Uniform Resource Identifier (URI) for, this License with every copy of the Work You Distribute or Publicly Perform. You may not offer or impose any terms on the Work that restrict the terms of this License or the ability of the recipient of the Work to exercise the rights granted to that recipient under the terms of the License. You may not sublicense the Work. You must keep intact all notices that refer to this License and to the disclaimer of warranties with every copy of the Work You Distribute or Publicly Perform. When You Distribute or Publicly Perform the Work, You may not impose any effective technological measures on the Work that restrict the ability of a recipient of the Work from You to exercise the rights granted to that recipient under the terms of the License. This Section 4(a) applies to the Work as incorporated in a Collection, but this does not require the Collection apart from the Work itself to be made subject to the terms of this License. If You create a Collection, upon notice from any Licensor You must, to the extent practicable, remove from the Collection any credit as required by Section 4(c), as requested. If You create an Adaptation, upon notice from any Licensor You must, to the extent practicable, remove from the Adaptation any credit as required by Section 4(c), as requested.

\item {} 
You may Distribute or Publicly Perform an Adaptation only under the terms of: (i) this License; (ii) a later version of this License with the same License Elements as this License; (iii) a Creative Commons jurisdiction license (either this or a later license version) that contains the same License Elements as this License (e.g., Attribution-ShareAlike 3.0 US)); (iv) a Creative Commons Compatible License. If you license the Adaptation under one of the licenses mentioned in (iv), you must comply with the terms of that license. If you license the Adaptation under the terms of any of the licenses mentioned in (i), (ii) or (iii) (the ``Applicable License''), you must comply with the terms of the Applicable License generally and the following provisions: (I) You must include a copy of, or the URI for, the Applicable License with every copy of each Adaptation You Distribute or Publicly Perform; (II) You may not offer or impose any terms on the Adaptation that restrict the terms of the Applicable License or the ability of the recipient of the Adaptation to exercise the rights granted to that recipient under the terms of the Applicable License; (III) You must keep intact all notices that refer to the Applicable License and to the disclaimer of warranties with every copy of the Work as included in the Adaptation You Distribute or Publicly Perform; (IV) when You Distribute or Publicly Perform the Adaptation, You may not impose any effective technological measures on the Adaptation that restrict the ability of a recipient of the Adaptation from You to exercise the rights granted to that recipient under the terms of the Applicable License. This Section 4(b) applies to the Adaptation as incorporated in a Collection, but this does not require the Collection apart from the Adaptation itself to be made subject to the terms of the Applicable License.

\item {} 
If You Distribute, or Publicly Perform the Work or any Adaptations or Collections, You must, unless a request has been made pursuant to Section 4(a), keep intact all copyright notices for the Work and provide, reasonable to the medium or means You are utilizing: (i) the name of the Original Author (or pseudonym, if applicable) if supplied, and/or if the Original Author and/or Licensor designate another party or parties (e.g., a sponsor institute, publishing entity, journal) for attribution (``Attribution Parties'') in Licensor's copyright notice, terms of service or by other reasonable means, the name of such party or parties; (ii) the title of the Work if supplied; (iii) to the extent reasonably practicable, the URI, if any, that Licensor specifies to be associated with the Work, unless such URI does not refer to the copyright notice or licensing information for the Work; and (iv) , consistent with Ssection 3(b), in the case of an Adaptation, a credit identifying the use of the Work in the Adaptation (e.g., ``French translation of the Work by Original Author,'' or ``Screenplay based on original Work by Original Author''). The credit required by this Section 4(c) may be implemented in any reasonable manner; provided, however, that in the case of a Adaptation or Collection, at a minimum such credit will appear, if a credit for all contributing authors of the Adaptation or Collection appears, then as part of these credits and in a manner at least as prominent as the credits for the other contributing authors. For the avoidance of doubt, You may only use the credit required by this Section for the purpose of attribution in the manner set out above and, by exercising Your rights under this License, You may not implicitly or explicitly assert or imply any connection with, sponsorship or endorsement by the Original Author, Licensor and/or Attribution Parties, as appropriate, of You or Your use of the Work, without the separate, express prior written permission of the Original Author, Licensor and/or Attribution Parties.

\item {} 
Except as otherwise agreed in writing by the Licensor or as may be otherwise permitted by applicable law, if You Reproduce, Distribute or Publicly Perform the Work either by itself or as part of any Adaptations or Collections, You must not distort, mutilate, modify or take other derogatory action in relation to the Work which would be prejudicial to the Original Author's honor or reputation. Licensor agrees that in those jurisdictions (e.g. Japan), in which any exercise of the right granted in Section 3(b) of this License (the right to make Adaptations) would be deemed to be a distortion, mutilation, modification or other derogatory action prejudicial to the Original Author's honor and reputation, the Licensor will waive or not assert, as appropriate, this Section, to the fullest extent permitted by the applicable national law, to enable You to reasonably exercise Your right under Section 3(b) of this License (right to make Adaptations) but not otherwise.

\end{enumerate}

\item {} 
Representations, Warranties and Disclaimer

\end{enumerate}

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
\begin{enumerate}
\item {} 
Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

\item {} 
Termination
\begin{enumerate}
\item {} 
This License and the rights granted hereunder will terminate automatically upon any breach by You of the terms of this License. Individuals or entities who have received Adaptations or Collections from You under this License, however, will not have their licenses terminated provided such individuals or entities remain in full compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this License.

\item {} 
Subject to the above terms and conditions, the license granted here is perpetual (for the duration of the applicable copyright in the Work). Notwithstanding the above, Licensor reserves the right to release the Work under different license terms or to stop distributing the Work at any time; provided, however that any such election will not serve to withdraw this License (or any other license that has been, or is required to be, granted under the terms of this License), and this License will continue in full force and effect unless terminated as stated above.

\end{enumerate}

\item {} 
Miscellaneous
\begin{enumerate}
\item {} 
Each time You Distribute or Publicly Perform the Work or a Collection, the Licensor offers to the recipient a license to the Work on the same terms and conditions as the license granted to You under this License.

\item {} 
Each time You Distribute or Publicly Perform an Adaptation, Licensor offers to the recipient a license to the original Work on the same terms and conditions as the license granted to You under this License.

\item {} 
If any provision of this License is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this License, and without further action by the parties to this agreement, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.

\item {} 
No term or provision of this License shall be deemed waived and no breach consented to unless such waiver or consent shall be in writing and signed by the party to be charged with such waiver or consent.

\item {} 
This License constitutes the entire agreement between the parties with respect to the Work licensed here. There are no understandings, agreements or representations with respect to the Work not specified here. Licensor shall not be bound by any additional provisions that may appear in any communication from You. This License may not be modified without the mutual written agreement of the Licensor and You.

\item {} 
The rights granted under, and the subject matter referenced, in this License were drafted utilizing the terminology of the Berne Convention for the Protection of Literary and Artistic Works (as amended on September 28, 1979), the Rome Convention of 1961, the WIPO Copyright Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and the Universal Copyright Convention (as revised on July 24, 1971). These rights and subject matter take effect in the relevant jurisdiction in which the License terms are sought to be enforced according to the corresponding provisions of the implementation of those treaty provisions in the applicable national law. If the standard suite of rights granted under applicable copyright law includes additional rights not granted under this License, such additional rights are deemed to be included in the License; this License is not intended to restrict the license of any rights under applicable law.

\end{enumerate}
\begin{quote}

Creative Commons Notice

Creative Commons is not a party to this License, and makes no warranty whatsoever in connection with the Work. Creative Commons will not be liable to You or any party on any legal theory for any damages whatsoever, including without limitation any general, special, incidental or consequential damages arising in connection to this license. Notwithstanding the foregoing two (2) sentences, if Creative Commons has expressly identified itself as the Licensor hereunder, it shall have all rights and obligations of Licensor.

Except for the limited purpose of indicating to the public that the Work is licensed under the CCPL, Creative Commons does not authorize the use by either party of the trademark ``Creative Commons'' or any related trademark or logo of Creative Commons without the prior written consent of Creative Commons. Any permitted use will be in compliance with Creative Commons' then-current trademark usage guidelines, as may be published on its website or otherwise made available upon request from time to time. For the avoidance of doubt, this trademark restriction does not form part of the License.

Creative Commons may be contacted at \href{http://creativecommons.org/}{http://creativecommons.org/}.
\end{quote}

\end{enumerate}

\begin{center}PSF LICENSE AGREEMENT FOR PYTHON 1.0
\end{center}\begin{enumerate}
\item {} 
This LICENSE AGREEMENT is between the Python Software Foundation (``PSF''), and
the Individual or Organization (``Licensee'') accessing and otherwise using Python
1.0 software in source or binary form and its associated documentation.

\item {} 
Subject to the terms and conditions of this License Agreement, PSF hereby
grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
analyze, test, perform and/or display publicly, prepare derivative works,
distribute, and otherwise use Python 1.0 alone or in any derivative
version, provided, however, that PSF's License Agreement and PSF's notice of
copyright, i.e., ``Copyright  2001-2010 Python Software Foundation; All Rights
Reserved'' are retained in Python 1.0 alone or in any derivative version
prepared by Licensee.

\item {} 
In the event Licensee prepares a derivative work that is based on or
incorporates Python 1.0 or any part thereof, and wants to make the
derivative work available to others as provided herein, then Licensee hereby
agrees to include in any such work a brief summary of the changes made to Python
1.0.

\item {} 
PSF is making Python 1.0 available to Licensee on an ``AS IS'' basis.
PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
USE OF PYTHON 1.0 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

\item {} 
PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 1.0
FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 1.0, OR ANY DERIVATIVE
THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

\item {} 
This License Agreement will automatically terminate upon a material breach of
its terms and conditions.

\item {} 
Nothing in this License Agreement shall be deemed to create any relationship
of agency, partnership, or joint venture between PSF and Licensee.  This License
Agreement does not grant permission to use PSF trademarks or trade name in a
trademark sense to endorse or promote products or services of Licensee, or any
third party.

\item {} 
By copying, installing or otherwise using Python 1.0, Licensee agrees
to be bound by the terms and conditions of this License Agreement.

\end{enumerate}

\begin{center}BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0
\end{center}
\begin{center}BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1
\end{center}\begin{enumerate}
\item {} 
This LICENSE AGREEMENT is between BeOpen.com (``BeOpen''), having an office at
160 Saratoga Avenue, Santa Clara, CA 95051, and the Individual or Organization
(``Licensee'') accessing and otherwise using this software in source or binary
form and its associated documentation (``the Software'').

\item {} 
Subject to the terms and conditions of this BeOpen Python License Agreement,
BeOpen hereby grants Licensee a non-exclusive, royalty-free, world-wide license
to reproduce, analyze, test, perform and/or display publicly, prepare derivative
works, distribute, and otherwise use the Software alone or in any derivative
version, provided, however, that the BeOpen Python License is retained in the
Software, alone or in any derivative version prepared by Licensee.

\item {} 
BeOpen is making the Software available to Licensee on an ``AS IS'' basis.
BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
USE OF THE SOFTWARE WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

\item {} 
BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE SOFTWARE FOR
ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF USING,
MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY DERIVATIVE THEREOF, EVEN IF
ADVISED OF THE POSSIBILITY THEREOF.

\item {} 
This License Agreement will automatically terminate upon a material breach of
its terms and conditions.

\item {} 
This License Agreement shall be governed by and interpreted in all respects
by the law of the State of California, excluding conflict of law provisions.
Nothing in this License Agreement shall be deemed to create any relationship of
agency, partnership, or joint venture between BeOpen and Licensee.  This License
Agreement does not grant permission to use BeOpen trademarks or trade names in a
trademark sense to endorse or promote products or services of Licensee, or any
third party.  As an exception, the ``BeOpen Python'' logos available at
\href{http://www.pythonlabs.com/logos.html}{http://www.pythonlabs.com/logos.html} may be used according to the permissions
granted on that web page.

\item {} 
By copying, installing or otherwise using the software, Licensee agrees to be
bound by the terms and conditions of this License Agreement.

\end{enumerate}


\chapter{Indices and tables}
\begin{itemize}
\item {} 
\emph{Index}

\item {} 
\emph{Module Index}

\item {} 
\emph{Search Page}

\end{itemize}


\renewcommand{\indexname}{Module Index}
\printmodindex
\renewcommand{\indexname}{Index}
\printindex
\end{document}
